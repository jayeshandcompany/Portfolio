{"version":3,"file":"index.es.js","sources":["../src/__internal__/with-meta.ts","../src/mark/strike-through.ts","../src/node/table/utils.ts","../src/node/table/index.ts","../src/node/footnote/definition.ts","../src/node/footnote/reference.ts","../src/node/task-list-item.ts","../src/composed/keymap.ts","../src/composed/inputrules.ts","../src/plugin/auto-insert-zero-space-plugin.ts","../src/plugin/column-resizing-plugin.ts","../src/plugin/table-editing-plugin.ts","../src/plugin/remark-gfm-plugin.ts","../src/composed/plugins.ts","../src/composed/schema.ts","../src/composed/commands.ts","../src/index.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport type { Meta, MilkdownPlugin } from '@milkdown/ctx'\n\nexport function withMeta<T extends MilkdownPlugin>(plugin: T, meta: Partial<Meta> & Pick<Meta, 'displayName'>): T {\n  Object.assign(plugin, {\n    meta: {\n      package: '@milkdown/preset-gfm',\n      ...meta,\n    },\n  })\n\n  return plugin\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { commandsCtx } from '@milkdown/core'\nimport { $command, $inputRule, $markAttr, $markSchema, $useKeymap } from '@milkdown/utils'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport { markRule } from '@milkdown/prose'\nimport { withMeta } from '../__internal__'\n\n/// HTML attributes for the strikethrough mark.\nexport const strikethroughAttr = $markAttr('strike_through')\n\nwithMeta(strikethroughAttr, {\n  displayName: 'Attr<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Strikethrough mark schema.\nexport const strikethroughSchema = $markSchema('strike_through', ctx => ({\n  parseDOM: [\n    { tag: 'del' },\n    { style: 'text-decoration', getAttrs: value => (value === 'line-through') as false },\n  ],\n  toDOM: mark => ['del', ctx.get(strikethroughAttr.key)(mark)],\n  parseMarkdown: {\n    match: node => node.type === 'delete',\n    runner: (state, node, markType) => {\n      state.openMark(markType)\n      state.next(node.children)\n      state.closeMark(markType)\n    },\n  },\n  toMarkdown: {\n    match: mark => mark.type.name === 'strike_through',\n    runner: (state, mark) => {\n      state.withMark(mark, 'delete')\n    },\n  },\n}))\n\nwithMeta(strikethroughSchema.mark, {\n  displayName: 'MarkSchema<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughSchema.ctx, {\n  displayName: 'MarkSchemaCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// A command to toggle the strikethrough mark.\nexport const toggleStrikethroughCommand = $command('ToggleStrikeThrough', ctx => () => {\n  return toggleMark(strikethroughSchema.type(ctx))\n})\n\nwithMeta(toggleStrikethroughCommand, {\n  displayName: 'Command<ToggleStrikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Input rule to create the strikethrough mark.\nexport const strikethroughInputRule = $inputRule((ctx) => {\n  return markRule(/~([^~]+)~$/, strikethroughSchema.type(ctx))\n})\n\nwithMeta(strikethroughInputRule, {\n  displayName: 'InputRule<strikethrough>',\n  group: 'Strikethrough',\n})\n\n/// Keymap for the strikethrough mark.\n/// - `Mod-Alt-x` - Toggle the strikethrough mark.\nexport const strikethroughKeymap = $useKeymap('strikeThroughKeymap', {\n  ToggleStrikethrough: {\n    shortcuts: 'Mod-Alt-x',\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n      return () => commands.call(toggleStrikethroughCommand.key)\n    },\n  },\n})\n\nwithMeta(strikethroughKeymap.ctx, {\n  displayName: 'KeymapCtx<strikethrough>',\n  group: 'Strikethrough',\n})\n\nwithMeta(strikethroughKeymap.shortcuts, {\n  displayName: 'Keymap<strikethrough>',\n  group: 'Strikethrough',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { ContentNodeWithPos } from '@milkdown/prose'\nimport { cloneTr, findParentNode } from '@milkdown/prose'\nimport type { Node } from '@milkdown/prose/model'\nimport type { Selection, Transaction } from '@milkdown/prose/state'\nimport type { TableRect } from '@milkdown/prose/tables'\nimport { CellSelection, TableMap } from '@milkdown/prose/tables'\n\nimport type { Ctx } from '@milkdown/ctx'\nimport { tableCellSchema, tableHeaderSchema, tableRowSchema, tableSchema } from '.'\n\n/// @internal\nexport interface CellPos {\n  pos: number\n  start: number\n  node: Node\n}\n\n/// @internal\nexport function createTable(ctx: Ctx, rowsCount = 3, colsCount = 3): Node {\n  const cells = Array(colsCount)\n    .fill(0)\n    .map(() => tableCellSchema.type(ctx).createAndFill()!)\n\n  const headerCells = Array(colsCount)\n    .fill(0)\n    .map(() => tableHeaderSchema.type(ctx).createAndFill()!)\n\n  const rows = Array(rowsCount)\n    .fill(0)\n    .map((_, i) => tableRowSchema.type(ctx).create(null, i === 0 ? headerCells : cells))\n\n  return tableSchema.type(ctx).create(null, rows)\n}\n\n/// Find the table node with position information for current selection.\nexport function findTable(selection: Selection) {\n  return findParentNode(node => node.type.spec.tableRole === 'table')(selection)\n}\n\n/// Get cells in a column of a table.\nexport function getCellsInCol(columnIndex: number, selection: Selection): CellPos[] | undefined {\n  const table = findTable(selection)\n  if (!table)\n    return undefined\n  const map = TableMap.get(table.node)\n  if (columnIndex < 0 || columnIndex >= map.width)\n    return undefined\n\n  return map\n    .cellsInRect({ left: columnIndex, right: columnIndex + 1, top: 0, bottom: map.height })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node)\n        return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get cells in a row of a table.\nexport function getCellsInRow(rowIndex: number, selection: Selection): CellPos[] | undefined {\n  const table = findTable(selection)\n  if (!table)\n    return undefined\n  const map = TableMap.get(table.node)\n  if (rowIndex < 0 || rowIndex >= map.height)\n    return undefined\n\n  return map\n    .cellsInRect({ left: 0, right: map.width, top: rowIndex, bottom: rowIndex + 1 })\n    .map((pos) => {\n      const node = table.node.nodeAt(pos)\n      if (!node)\n        return undefined\n      const start = pos + table.start\n      return {\n        pos: start,\n        start: start + 1,\n        node,\n      }\n    })\n    .filter((x): x is CellPos => x != null)\n}\n\n/// Get all cells in a table.\nexport function getAllCellsInTable(selection: Selection) {\n  const table = findTable(selection)\n  if (!table)\n    return\n\n  const map = TableMap.get(table.node)\n  const cells = map.cellsInRect({\n    left: 0,\n    right: map.width,\n    top: 0,\n    bottom: map.height,\n  })\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos)\n    const pos = nodePos + table.start\n    return { pos, start: pos + 1, node }\n  })\n}\n\n/// Select a possible table in current selection.\nexport function selectTable(tr: Transaction) {\n  const cells = getAllCellsInTable(tr.selection)\n  if (cells && cells[0]) {\n    const $firstCell = tr.doc.resolve(cells[0].pos)\n    const last = cells[cells.length - 1]\n    if (last) {\n      const $lastCell = tr.doc.resolve(last.pos)\n      return cloneTr(tr.setSelection(new CellSelection($lastCell, $firstCell)))\n    }\n  }\n  return tr\n}\n\n/// @internal\nexport function addRowWithAlignment(ctx: Ctx, tr: Transaction, { map, tableStart, table }: TableRect, row: number) {\n  const rowPos = Array(row)\n    .fill(0)\n    .reduce((acc, _, i) => {\n      return acc + table.child(i).nodeSize\n    }, tableStart)\n\n  const cells = Array(map.width)\n    .fill(0)\n    .map((_, col) => {\n      const headerCol = table.nodeAt(map.map[col] as number)\n      return tableCellSchema.type(ctx).createAndFill({ alignment: headerCol?.attrs.alignment }) as Node\n    })\n\n  tr.insert(rowPos, tableRowSchema.type(ctx).create(null, cells))\n  return tr\n}\n\n/// @internal\nexport function selectLine(type: 'row' | 'col') {\n  return (index: number) => (tr: Transaction) => {\n    const table = findTable(tr.selection)\n    const isRowSelection = type === 'row'\n    if (table) {\n      const map = TableMap.get(table.node)\n\n      // Check if the index is valid\n      if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {\n        const lastCell = map.positionAt(\n          isRowSelection ? index : map.height - 1,\n          isRowSelection ? map.width - 1 : index,\n          table.node,\n        )\n        const $lastCell = tr.doc.resolve(table.start + lastCell)\n\n        const createCellSelection = isRowSelection ? CellSelection.rowSelection : CellSelection.colSelection\n\n        const firstCell = map.positionAt(isRowSelection ? index : 0, isRowSelection ? 0 : index, table.node)\n        const $firstCell = tr.doc.resolve(table.start + firstCell)\n        return cloneTr(tr.setSelection(createCellSelection($lastCell, $firstCell) as unknown as Selection))\n      }\n    }\n    return tr\n  }\n}\n\n/// If the selection is in a table,\n/// select the {index} row.\nexport const selectRow = selectLine('row')\n\n/// If the selection is in a table,\n/// select the {index} column.\nexport const selectCol = selectLine('col')\n\nfunction transpose<T>(array: T[][]) {\n  return array[0]!.map((_, i) => {\n    return array.map(column => column[i])\n  }) as T[][]\n}\n\nfunction convertArrayOfRowsToTableNode(tableNode: Node, arrayOfNodes: (Node | null)[][]) {\n  const rowsPM = []\n  const map = TableMap.get(tableNode)\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const row = tableNode.child(rowIndex)\n    const rowCells = []\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      if (!arrayOfNodes[rowIndex]![colIndex])\n        continue\n\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n\n      const cell = arrayOfNodes[rowIndex]![colIndex]!\n      const oldCell = tableNode.nodeAt(cellPos)!\n      const newCell = oldCell.type.createChecked(\n        Object.assign({}, cell.attrs),\n        cell.content,\n        cell.marks,\n      )\n      rowCells.push(newCell)\n    }\n\n    rowsPM.push(row.type.createChecked(row.attrs, rowCells, row.marks))\n  }\n\n  const newTable = tableNode.type.createChecked(\n    tableNode.attrs,\n    rowsPM,\n    tableNode.marks,\n  )\n\n  return newTable\n}\n\nfunction convertTableNodeToArrayOfRows(tableNode: Node) {\n  const map = TableMap.get(tableNode)\n  const rows: (Node | null)[][] = []\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const rowCells: (Node | null)[] = []\n    const seen: Record<number, boolean> = {}\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      const cellPos = map.map[rowIndex * map.width + colIndex]!\n      const cell = tableNode.nodeAt(cellPos)\n      const rect = map.findCell(cellPos)\n      if (seen[cellPos] || rect.top !== rowIndex) {\n        rowCells.push(null)\n        continue\n      }\n      seen[cellPos] = true\n\n      rowCells.push(cell)\n    }\n\n    rows.push(rowCells)\n  }\n\n  return rows\n}\n\nfunction moveRowInArrayOfRows(rows: (Node | null)[][], indexesOrigin: number[], indexesTarget: number[], directionOverride: -1 | 1 | 0) {\n  const direction = indexesOrigin[0]! > indexesTarget[0]! ? -1 : 1\n\n  const rowsExtracted = rows.splice(indexesOrigin[0]!, indexesOrigin.length)\n  const positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0\n  let target: number\n\n  if (directionOverride === -1 && direction === 1) {\n    target = indexesTarget[0]! - 1\n  }\n  else if (directionOverride === 1 && direction === -1) {\n    target = indexesTarget[indexesTarget.length - 1]! - positionOffset + 1\n  }\n  else {\n    target\n      = direction === -1\n        ? indexesTarget[0]!\n        : indexesTarget[indexesTarget.length - 1]! - positionOffset\n  }\n\n  rows.splice(target, 0, ...rowsExtracted)\n  return rows\n}\n\nfunction moveTableColumn(table: ContentNodeWithPos, indexesOrigin: number[], indexesTarget: number[], direction: -1 | 1 | 0) {\n  let rows = transpose(convertTableNodeToArrayOfRows(table.node))\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n  rows = transpose(rows)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nfunction moveTableRow(table: ContentNodeWithPos, indexesOrigin: number[], indexesTarget: number[], direction: -1 | 1 | 0) {\n  let rows = convertTableNodeToArrayOfRows(table.node)\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction)\n\n  return convertArrayOfRowsToTableNode(table.node, rows)\n}\n\nfunction getSelectionRangeInColumn(columnIndex: number, tr: Transaction) {\n  let startIndex = columnIndex\n  let endIndex = columnIndex\n\n  // looking for selection start column (startIndex)\n  for (let i = columnIndex; i >= 0; i--) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (maybeEndIndex >= startIndex)\n          startIndex = i\n\n        if (maybeEndIndex > endIndex)\n          endIndex = maybeEndIndex\n      })\n    }\n  }\n  // looking for selection end column (endIndex)\n  for (let i = columnIndex; i <= endIndex; i++) {\n    const cells = getCellsInCol(i, tr.selection)\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1\n        if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex)\n          endIndex = maybeEndIndex\n      })\n    }\n  }\n\n  // filter out columns without cells (where all rows have colspan > 1 in the same column)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInCol(i, tr.selection)\n    if (maybeCells && maybeCells.length)\n      indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedColumnCells = getCellsInCol(startIndex, tr.selection)!\n  const firstRowCells = getCellsInRow(0, tr.selection)!\n  const $anchor = tr.doc.resolve(\n    firstSelectedColumnCells[firstSelectedColumnCells.length - 1]!.pos,\n  )\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const columnCells = getCellsInCol(i, tr.selection)\n    if (columnCells && columnCells.length) {\n      for (let j = firstRowCells.length - 1; j >= 0; j--) {\n        if (firstRowCells[j]!.pos === columnCells[0]!.pos) {\n          headCell = columnCells[0]\n          break\n        }\n      }\n      if (headCell)\n        break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\nfunction getSelectionRangeInRow(rowIndex: number, tr: Transaction) {\n  let startIndex = rowIndex\n  let endIndex = rowIndex\n  // looking for selection start row (startIndex)\n  for (let i = rowIndex; i >= 0; i--) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (maybeEndIndex >= startIndex)\n        startIndex = i\n\n      if (maybeEndIndex > endIndex)\n        endIndex = maybeEndIndex\n    })\n  }\n  // looking for selection end row (endIndex)\n  for (let i = rowIndex; i <= endIndex; i++) {\n    const cells = getCellsInRow(i, tr.selection)\n    cells!.forEach((cell) => {\n      const maybeEndIndex = cell.node.attrs.rowspan + i - 1\n      if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex)\n        endIndex = maybeEndIndex\n    })\n  }\n\n  // filter out rows without cells (where all columns have rowspan > 1 in the same row)\n  const indexes = []\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInRow(i, tr.selection)\n    if (maybeCells && maybeCells.length)\n      indexes.push(i)\n  }\n  startIndex = indexes[0]!\n  endIndex = indexes[indexes.length - 1]!\n\n  const firstSelectedRowCells = getCellsInRow(startIndex, tr.selection)!\n  const firstColumnCells = getCellsInCol(0, tr.selection)!\n  const $anchor = tr.doc.resolve(firstSelectedRowCells[firstSelectedRowCells.length - 1]!.pos)\n\n  let headCell: CellPos | undefined\n  for (let i = endIndex; i >= startIndex; i--) {\n    const rowCells = getCellsInRow(i, tr.selection)\n    if (rowCells && rowCells.length) {\n      for (let j = firstColumnCells.length - 1; j >= 0; j--) {\n        if (firstColumnCells[j]!.pos === rowCells[0]!.pos) {\n          headCell = rowCells[0]!\n          break\n        }\n      }\n      if (headCell)\n        break\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell!.pos)\n  return { $anchor, $head, indexes }\n}\n\n/// If the selection is in a table,\n/// Move the columns at `origin` to `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved column.\nexport function moveCol(tr: Transaction, origin: number, target: number, select = true) {\n  const table = findTable(tr.selection)\n  if (!table)\n    return tr\n\n  const { indexes: indexesOriginColumn } = getSelectionRangeInColumn(origin, tr)\n  const { indexes: indexesTargetColumn } = getSelectionRangeInColumn(target, tr)\n\n  if (indexesOriginColumn.includes(target))\n    return tr\n\n  const newTable = moveTableColumn(\n    table,\n    indexesOriginColumn,\n    indexesTargetColumn,\n    0,\n  )\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable,\n  )\n\n  if (!select)\n    return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(map.height - 1, index, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.colSelection\n\n  const firstCell = map.positionAt(0, index, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n\n/// If the selection is in a table,\n/// Move the rows at `origin` and `target` in current table.\n/// The `select` is true by default, which means the selection will be set to the moved row.\nexport function moveRow(tr: Transaction, origin: number, target: number, select = true) {\n  const table = findTable(tr.selection)\n  if (!table)\n    return tr\n\n  const { indexes: indexesOriginRow } = getSelectionRangeInRow(origin, tr)\n  const { indexes: indexesTargetRow } = getSelectionRangeInRow(target, tr)\n\n  if (indexesOriginRow.includes(target))\n    return tr\n\n  const newTable = moveTableRow(\n    table,\n    indexesOriginRow,\n    indexesTargetRow,\n    0,\n  )\n\n  const _tr = cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable,\n  )\n\n  if (!select)\n    return _tr\n\n  const map = TableMap.get(newTable)\n  const start = table.start\n  const index = target\n  const lastCell = map.positionAt(index, map.width - 1, newTable)\n  const $lastCell = _tr.doc.resolve(start + lastCell)\n\n  const createCellSelection = CellSelection.rowSelection\n\n  const firstCell = map.positionAt(index, 0, newTable)\n  const $firstCell = _tr.doc.resolve(start + firstCell)\n\n  return _tr.setSelection(createCellSelection($lastCell, $firstCell))\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MarkdownNode } from '@milkdown/transformer'\nimport { commandsCtx } from '@milkdown/core'\nimport { paragraphSchema } from '@milkdown/preset-commonmark'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport type { NodeType } from '@milkdown/prose/model'\nimport { Selection, TextSelection } from '@milkdown/prose/state'\nimport { CellSelection, addColumnAfter, addColumnBefore, deleteColumn, deleteRow, deleteTable, goToNextCell, isInTable, selectedRect, setCellAttr, tableNodes } from '@milkdown/prose/tables'\nimport { $command, $inputRule, $nodeSchema, $useKeymap } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\nimport { addRowWithAlignment, createTable, moveCol, moveRow, selectCol, selectRow, selectTable } from './utils'\n\nconst originalSchema = tableNodes({\n  tableGroup: 'block',\n  cellContent: 'paragraph',\n  cellAttributes: {\n    alignment: {\n      default: 'left',\n      getFromDOM: dom => (dom).style.textAlign || 'left',\n      setDOMAttr: (value, attrs) => {\n        attrs.style = `text-align: ${value || 'left'}`\n      },\n    },\n  },\n})\n\n/// Schema for table node.\nexport const tableSchema = $nodeSchema('table', () => ({\n  ...originalSchema.table,\n  parseMarkdown: {\n    match: node => node.type === 'table',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align,\n        isHeader: i === 0,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table',\n    runner: (state, node) => {\n      const firstLine = node.content.firstChild?.content\n      if (!firstLine)\n        return\n\n      const align: (string | null)[] = []\n      firstLine.forEach((cell) => {\n        align.push(cell.attrs.alignment)\n      })\n      state.openNode('table', undefined, { align })\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableSchema.node, {\n  displayName: 'NodeSchema<table>',\n  group: 'Table',\n})\n\nwithMeta(tableSchema.ctx, {\n  displayName: 'NodeSchemaCtx<table>',\n  group: 'Table',\n})\n\n/// Schema for table row node.\nexport const tableRowSchema = $nodeSchema('table_row', () => ({\n  ...originalSchema.table_row,\n  parseMarkdown: {\n    match: node => node.type === 'tableRow',\n    runner: (state, node, type) => {\n      const align = node.align as (string | null)[]\n      const children = (node.children as MarkdownNode[]).map((x, i) => ({\n        ...x,\n        align: align[i],\n        isHeader: node.isHeader,\n      }))\n      state.openNode(type)\n      state.next(children)\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_row',\n    runner: (state, node) => {\n      state.openNode('tableRow')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableRowSchema.node, {\n  displayName: 'NodeSchema<tableRow>',\n  group: 'Table',\n})\n\nwithMeta(tableRowSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableRow>',\n  group: 'Table',\n})\n\n/// Schema for table cell node.\nexport const tableCellSchema = $nodeSchema('table_cell', () => ({\n  ...originalSchema.table_cell,\n  parseMarkdown: {\n    match: node => node.type === 'tableCell' && !node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state\n        .openNode(type, { alignment: align })\n        .openNode(state.schema.nodes.paragraph as NodeType)\n        .next(node.children)\n        .closeNode()\n        .closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_cell',\n    runner: (state, node) => {\n      state.openNode('tableCell').next(node.content).closeNode()\n    },\n  },\n}))\n\nwithMeta(tableCellSchema.node, {\n  displayName: 'NodeSchema<tableCell>',\n  group: 'Table',\n})\n\nwithMeta(tableCellSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableCell>',\n  group: 'Table',\n})\n\n/// Schema for table header node.\nexport const tableHeaderSchema = $nodeSchema('table_header', () => ({\n  ...originalSchema.table_header,\n  parseMarkdown: {\n    match: node => node.type === 'tableCell' && !!node.isHeader,\n    runner: (state, node, type) => {\n      const align = node.align as string\n      state.openNode(type, { alignment: align })\n      state.openNode(state.schema.nodes.paragraph as NodeType)\n      state.next(node.children)\n      state.closeNode()\n      state.closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === 'table_header',\n    runner: (state, node) => {\n      state.openNode('tableCell')\n      state.next(node.content)\n      state.closeNode()\n    },\n  },\n}))\n\nwithMeta(tableHeaderSchema.node, {\n  displayName: 'NodeSchema<tableHeader>',\n  group: 'Table',\n})\n\nwithMeta(tableHeaderSchema.ctx, {\n  displayName: 'NodeSchemaCtx<tableHeader>',\n  group: 'Table',\n})\n\n/// A input rule for creating table.\n/// For example, `|2x2|` will create a 2x2 table.\nexport const insertTableInputRule = $inputRule(ctx => new InputRule(\n  /^\\|(?<col>\\d+)[xX](?<row>\\d+)\\|\\s$/,\n  (state, match, start, end) => {\n    const $start = state.doc.resolve(start)\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), tableSchema.type(ctx)))\n      return null\n\n    const tableNode = createTable(\n      ctx,\n      Number(match.groups?.row),\n      Number(match.groups?.col),\n    )\n    const tr = state.tr.replaceRangeWith(start, end, tableNode)\n    return tr.setSelection(TextSelection.create(tr.doc, start + 3)).scrollIntoView()\n  },\n))\n\nwithMeta(insertTableInputRule, {\n  displayName: 'InputRule<insertTableInputRule>',\n  group: 'Table',\n})\n\n/// A command for moving cursor to previous cell.\nexport const goToPrevTableCellCommand = $command('GoToPrevTableCell', () => () => goToNextCell(-1))\n\nwithMeta(goToPrevTableCellCommand, {\n  displayName: 'Command<goToPrevTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for moving cursor to next cell.\nexport const goToNextTableCellCommand = $command('GoToNextTableCell', () => () => goToNextCell(1))\n\nwithMeta(goToNextTableCellCommand, {\n  displayName: 'Command<goToNextTableCellCommand>',\n  group: 'Table',\n})\n\n/// A command for splitting current table into two tables.\n/// If the selection is at the end of the table,\n/// it will just quit the table and insert a new paragraph node.\nexport const breakTableCommand = $command('BreakTable', ctx => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n\n  const { $head } = state.selection\n  const pos = $head.after()\n  const tr = state.tr\n    .replaceWith(pos, pos, paragraphSchema.type(ctx).createAndFill()!)\n\n  tr.setSelection(Selection.near(tr.doc.resolve(pos), 1)).scrollIntoView()\n  dispatch?.(tr)\n  return true\n})\n\nwithMeta(breakTableCommand, {\n  displayName: 'Command<breakTableCommand>',\n  group: 'Table',\n})\n\n/// A command for inserting a table.\n/// You can specify the number of rows and columns.\n/// By default, it will insert a 3x3 table.\nexport const insertTableCommand = $command('InsertTable', ctx => ({ row, col }: { row?: number, col?: number } = {}) => (state, dispatch) => {\n  const { selection, tr } = state\n  const { from } = selection\n  const table = createTable(ctx, row, col)\n  const _tr = tr.replaceSelectionWith(table)\n  const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true)\n  if (sel)\n    _tr.setSelection(sel)\n\n  dispatch?.(_tr)\n\n  return true\n})\n\nwithMeta(insertTableCommand, {\n  displayName: 'Command<insertTableCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a row in a table.\n/// You should specify the `from` and `to` index.\nexport const moveRowCommand = $command('MoveRow', () => ({ from, to }: { from?: number, to?: number } = {}) => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(moveRow(tr, from ?? 0, to ?? 0, true))\n\n  return Boolean(result)\n})\n\nwithMeta(moveRowCommand, {\n  displayName: 'Command<moveRowCommand>',\n  group: 'Table',\n})\n\n/// A command for moving a column in a table.\n/// You should specify the `from` and `to` index.\nexport const moveColCommand = $command('MoveCol', () => ({ from, to }: { from?: number, to?: number } = {}) => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(moveCol(tr, from ?? 0, to ?? 0, true))\n\n  return Boolean(result)\n})\n\nwithMeta(moveColCommand, {\n  displayName: 'Command<moveColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a row.\nexport const selectRowCommand = $command<number, 'SelectRow'>('SelectRow', () => (index = 0) => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(selectRow(index)(tr))\n\n  return Boolean(result)\n})\n\nwithMeta(selectRowCommand, {\n  displayName: 'Command<selectRowCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a column.\nexport const selectColCommand = $command<number, 'SelectCol'>('SelectCol', () => (index = 0) => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(selectCol(index)(tr))\n\n  return Boolean(result)\n})\n\nwithMeta(selectColCommand, {\n  displayName: 'Command<selectColCommand>',\n  group: 'Table',\n})\n\n/// A command for selecting a table.\nexport const selectTableCommand = $command('SelectTable', () => () => (state, dispatch) => {\n  const { tr } = state\n  const result = dispatch?.(selectTable(tr))\n\n  return Boolean(result)\n})\n\nwithMeta(selectTableCommand, {\n  displayName: 'Command<selectTableCommand>',\n  group: 'Table',\n})\n\n/// A command for deleting selected cells.\n/// If the selection is a row or column, the row or column will be deleted.\n/// If all cells are selected, the table will be deleted.\nexport const deleteSelectedCellsCommand = $command('DeleteSelectedCells', () => () => (state, dispatch) => {\n  const { selection } = state\n  if (!(selection instanceof CellSelection))\n    return false\n\n  const isRow = selection.isRowSelection()\n  const isCol = selection.isColSelection()\n\n  if (isRow && isCol)\n    return deleteTable(state, dispatch)\n\n  if (isCol)\n    return deleteColumn(state, dispatch)\n\n  else\n    return deleteRow(state, dispatch)\n})\n\nwithMeta(deleteSelectedCellsCommand, {\n  displayName: 'Command<deleteSelectedCellsCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column before the current column.\nexport const addColBeforeCommand = $command('AddColBefore', () => () => addColumnBefore)\n\nwithMeta(addColBeforeCommand, {\n  displayName: 'Command<addColBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a column after the current column.\nexport const addColAfterCommand = $command('AddColAfter', () => () => addColumnAfter)\n\nwithMeta(addColAfterCommand, {\n  displayName: 'Command<addColAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row before the current row.\nexport const addRowBeforeCommand = $command('AddRowBefore', ctx => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n  if (dispatch) {\n    const rect = selectedRect(state)\n    dispatch(addRowWithAlignment(ctx, state.tr, rect, rect.top))\n  }\n  return true\n})\n\nwithMeta(addRowBeforeCommand, {\n  displayName: 'Command<addRowBeforeCommand>',\n  group: 'Table',\n})\n\n/// A command for adding a row after the current row.\nexport const addRowAfterCommand = $command('AddRowAfter', ctx => () => (state, dispatch) => {\n  if (!isInTable(state))\n    return false\n  if (dispatch) {\n    const rect = selectedRect(state)\n    dispatch(addRowWithAlignment(ctx, state.tr, rect, rect.bottom))\n  }\n  return true\n})\n\nwithMeta(addRowAfterCommand, {\n  displayName: 'Command<addRowAfterCommand>',\n  group: 'Table',\n})\n\n/// A command for setting alignment property for selected cells.\n/// You can specify the alignment as `left`, `center`, or `right`.\n/// It's `left` by default.\nexport const setAlignCommand = $command<'left' | 'center' | 'right', 'SetAlign'>('SetAlign', () => (alignment = 'left') => setCellAttr('alignment', alignment))\n\nwithMeta(setAlignCommand, {\n  displayName: 'Command<setAlignCommand>',\n  group: 'Table',\n})\n\n/// Keymap for table commands.\n/// - `<Mod-]>`/`<Tab>`: Move to the next cell.\n/// - `<Mod-[>`/`<Shift-Tab>`: Move to the previous cell.\n/// - `<Mod-Enter>`: Exit the table, and break it if possible.\nexport const tableKeymap = $useKeymap('tableKeymap', {\n  NextCell: {\n    shortcuts: ['Mod-]', 'Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToNextTableCellCommand.key)\n    },\n  },\n  PrevCell: {\n    shortcuts: ['Mod-[', 'Shift-Tab'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(goToPrevTableCellCommand.key)\n    },\n  },\n  ExitTable: {\n    shortcuts: ['Mod-Enter'],\n    command: (ctx) => {\n      const commands = ctx.get(commandsCtx)\n\n      return () => commands.call(breakTableCommand.key)\n    },\n  },\n})\n\nwithMeta(tableKeymap.ctx, {\n  displayName: 'KeymapCtx<table>',\n  group: 'Table',\n})\n\nwithMeta(tableKeymap.shortcuts, {\n  displayName: 'Keymap<table>',\n  group: 'Table',\n})\n\nexport * from './utils'\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_definition'\nconst markdownId = 'footnoteDefinition'\n\n/// Footnote definition node schema.\nexport const footnoteDefinitionSchema = $nodeSchema('footnote_definition', () => ({\n  group: 'block',\n  content: 'block+',\n  defining: true,\n  attrs: {\n    label: {\n      default: '',\n    },\n  },\n  parseDOM: [\n    {\n      tag: `dl[data-type=\"${id}\"]`,\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement))\n          throw expectDomTypeError(dom)\n\n        return {\n          label: dom.dataset.label,\n        }\n      },\n      contentElement: 'dd',\n    },\n  ],\n  toDOM: (node) => {\n    const label = node.attrs.label\n\n    return [\n      'dl',\n      {\n        // TODO: add a prosemirror plugin to sync label on change\n        'data-label': label,\n        'data-type': id,\n      },\n      ['dt', label],\n      ['dd', 0],\n    ]\n  },\n  parseMarkdown: {\n    match: ({ type }) => type === markdownId,\n    runner: (state, node, type) => {\n      state\n        .openNode(type, {\n          label: node.label as string,\n        })\n        .next(node.children)\n        .closeNode()\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === id,\n    runner: (state, node) => {\n      state\n        .openNode(markdownId, undefined, {\n          label: node.attrs.label,\n          identifier: node.attrs.label,\n        })\n        .next(node.content)\n        .closeNode()\n    },\n  },\n}))\n\nwithMeta(footnoteDefinitionSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeDef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteDefinitionSchema.node, {\n  displayName: 'NodeSchema<footnodeDef>',\n  group: 'footnote',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { $nodeSchema } from '@milkdown/utils'\nimport { withMeta } from '../../__internal__'\n\nconst id = 'footnote_reference'\n\n/// Footnote reference node schema.\nexport const footnoteReferenceSchema = $nodeSchema('footnote_reference', () => ({\n  group: 'inline',\n  inline: true,\n  atom: true,\n  attrs: {\n    label: {\n      default: '',\n    },\n  },\n  parseDOM: [\n    {\n      tag: `sup[data-type=\"${id}\"]`,\n      getAttrs: (dom) => {\n        if (!(dom instanceof HTMLElement))\n          throw expectDomTypeError(dom)\n\n        return {\n          label: dom.dataset.label,\n        }\n      },\n    },\n  ],\n  toDOM: (node) => {\n    const label = node.attrs.label\n    return [\n      'sup',\n      {\n        // TODO: add a prosemirror plugin to sync label on change\n        'data-label': label,\n        'data-type': id,\n      },\n      label,\n    ]\n  },\n  parseMarkdown: {\n    match: ({ type }) => type === 'footnoteReference',\n    runner: (state, node, type) => {\n      state.addNode(type, {\n        label: node.label as string,\n      })\n    },\n  },\n  toMarkdown: {\n    match: node => node.type.name === id,\n    runner: (state, node) => {\n      state.addNode('footnoteReference', undefined, undefined, {\n        label: node.attrs.label,\n        identifier: node.attrs.label,\n      })\n    },\n  },\n}))\n\nwithMeta(footnoteReferenceSchema.ctx, {\n  displayName: 'NodeSchemaCtx<footnodeRef>',\n  group: 'footnote',\n})\n\nwithMeta(footnoteReferenceSchema.node, {\n  displayName: 'NodeSchema<footnodeRef>',\n  group: 'footnote',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { listItemSchema } from '@milkdown/preset-commonmark'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { $inputRule } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This schema extends the [list item](/preset-commonmark#list-item) schema and add task list support for it.\nexport const extendListItemSchemaForTask = listItemSchema.extendSchema((prev) => {\n  return (ctx) => {\n    const baseSchema = prev(ctx)\n    return {\n      ...baseSchema,\n      attrs: {\n        ...baseSchema.attrs,\n        checked: {\n          default: null,\n        },\n      },\n      parseDOM: [\n        {\n          tag: 'li[data-item-type=\"task\"]',\n          getAttrs: (dom) => {\n            if (!(dom instanceof HTMLElement))\n              throw expectDomTypeError(dom)\n\n            return {\n              label: dom.dataset.label,\n              listType: dom.dataset['list-type'],\n              spread: dom.dataset.spread,\n              checked: dom.dataset.checked ? dom.dataset.checked === 'true' : null,\n            }\n          },\n        },\n        ...baseSchema?.parseDOM || [],\n      ],\n      toDOM: (node) => {\n        if (baseSchema.toDOM && node.attrs.checked == null)\n          return baseSchema.toDOM(node)\n\n        return [\n          'li',\n          {\n            'data-item-type': 'task',\n            'data-label': node.attrs.label,\n            'data-list-type': node.attrs.listType,\n            'data-spread': node.attrs.spread,\n            'data-checked': node.attrs.checked,\n          },\n          0,\n        ]\n      },\n      parseMarkdown: {\n        match: ({ type }) => type === 'listItem',\n        runner: (state, node, type) => {\n          if (node.checked == null) {\n            baseSchema.parseMarkdown.runner(state, node, type)\n            return\n          }\n\n          const label = node.label != null ? `${node.label}.` : 'â€¢'\n          const checked = node.checked != null ? Boolean(node.checked) : null\n          const listType = node.label != null ? 'ordered' : 'bullet'\n          const spread = node.spread != null ? `${node.spread}` : 'true'\n\n          state.openNode(type, { label, listType, spread, checked })\n          state.next(node.children)\n          state.closeNode()\n        },\n      },\n      toMarkdown: {\n        match: node => node.type.name === 'list_item',\n        runner: (state, node) => {\n          if (node.attrs.checked == null) {\n            baseSchema.toMarkdown.runner(state, node)\n            return\n          }\n\n          const label = node.attrs.label\n          const listType = node.attrs.listType\n          const spread = node.attrs.spread === 'true'\n          const checked = node.attrs.checked\n\n          state.openNode('listItem', undefined, { label, listType, spread, checked })\n          state.next(node.content)\n          state.closeNode()\n        },\n      },\n    }\n  }\n})\n\nwithMeta(extendListItemSchemaForTask, {\n  displayName: 'NodeSchema<listItem>',\n  group: 'ListItem',\n})\n\n/// Input rule for wrapping a block in task list node.\n/// Users can type `[ ] ` or `[x] ` to wrap the block in task list node with checked status.\nexport const wrapInTaskListInputRule = $inputRule(() => {\n  return new InputRule(/^\\[(?<checked>\\s|x)\\]\\s$/, (state, match, start, end) => {\n    const pos = state.doc.resolve(start)\n    let depth = 0\n    let node = pos.node(depth)\n    while (node && node.type.name !== 'list_item') {\n      depth--\n      node = pos.node(depth)\n    }\n\n    if (!node || node.attrs.checked != null)\n      return null\n\n    const checked = Boolean(match.groups?.checked === 'x')\n\n    const finPos = pos.before(depth)\n    const tr = state.tr\n\n    tr.deleteRange(start, end)\n      .setNodeMarkup(finPos, undefined, { ...node.attrs, checked })\n\n    return tr\n  })\n})\n\nwithMeta(wrapInTaskListInputRule, {\n  displayName: 'InputRule<wrapInTaskListInputRule>',\n  group: 'ListItem',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin } from '@milkdown/ctx'\nimport { strikethroughKeymap } from '../mark'\nimport { tableKeymap } from '../node'\n\n/// @internal\nexport const keymap: MilkdownPlugin[] = [\n  strikethroughKeymap,\n  tableKeymap,\n].flat()\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin } from '@milkdown/ctx'\nimport { insertTableInputRule, wrapInTaskListInputRule } from '../node'\nimport { strikethroughInputRule } from '../mark'\n\n/// @internal\nexport const inputRules: MilkdownPlugin[] = [\n  insertTableInputRule,\n  wrapInTaskListInputRule,\n]\n\nexport const markInputRules: MilkdownPlugin[] = [\n  strikethroughInputRule,\n]\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { browser } from '@milkdown/prose'\nimport type { Node } from '@milkdown/prose/model'\nimport { isInTable } from '@milkdown/prose/tables'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { paragraphSchema } from '@milkdown/preset-commonmark'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is used to fix the bug of IME composing in table in Safari browser.\n/// original discussion in https://discuss.prosemirror.net/t/ime-composing-problems-on-td-or-th-element-in-safari-browser/4501\nexport const autoInsertZeroSpaceInTablePlugin = $prose((ctx) => {\n  const pluginKey = new PluginKey('MILKDOWN_AUTO_INSERT_ZERO_SPACE')\n\n  const isParagraph = (node: Node) => node.type === paragraphSchema.type(ctx)\n\n  const isEmptyParagraph = (node: Node) => isParagraph(node) && node.nodeSize === 2\n\n  return new Plugin({\n    key: pluginKey,\n    props: {\n      handleDOMEvents: {\n        compositionstart(view) {\n          const { state, dispatch } = view\n          const { tr, selection } = state\n          const { $from } = selection\n          if (browser.safari && isInTable(state) && selection.empty && isEmptyParagraph($from.parent))\n            dispatch(tr.insertText('\\u2060', $from.start()))\n\n          return false\n        },\n        compositionend(view) {\n          const { state, dispatch } = view\n          const { tr, selection } = state\n          const { $from } = selection\n\n          if (\n            browser.safari\n            && isInTable(state)\n            && selection.empty\n            && isParagraph($from.parent)\n            && $from.parent.textContent.startsWith('\\u2060')\n          )\n            dispatch(tr.delete($from.start(), $from.start() + 1))\n\n          return false\n        },\n      },\n    },\n  })\n})\n\nwithMeta(autoInsertZeroSpaceInTablePlugin, {\n  displayName: 'Prose<autoInsertZeroSpaceInTablePlugin>',\n  group: 'Prose',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { columnResizing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `columnResizing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const columnResizingPlugin = $prose(() => columnResizing({}))\n\nwithMeta(columnResizingPlugin, {\n  displayName: 'Prose<columnResizingPlugin>',\n  group: 'Prose',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { tableEditing } from '@milkdown/prose/tables'\nimport { $prose } from '@milkdown/utils'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the `tableEditing` plugin from [prosemirror-tables](https://github.com/ProseMirror/prosemirror-tables).\nexport const tableEditingPlugin = $prose(() => tableEditing())\n\nwithMeta(tableEditingPlugin, {\n  displayName: 'Prose<tableEditingPlugin>',\n  group: 'Prose',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { $Remark } from '@milkdown/utils'\nimport { $remark } from '@milkdown/utils'\nimport type { Options } from 'remark-gfm'\nimport remarkGFM from 'remark-gfm'\nimport { withMeta } from '../__internal__'\n\n/// This plugin is wrapping the [remark-gfm](https://github.com/remarkjs/remark-gfm).\nexport const remarkGFMPlugin: $Remark<'remarkGFM', Options | null | undefined> = $remark('remarkGFM', () => remarkGFM)\n\nwithMeta(remarkGFMPlugin.plugin, {\n  displayName: 'Remark<remarkGFMPlugin>',\n  group: 'Remark',\n})\n\nwithMeta(remarkGFMPlugin.options, {\n  displayName: 'RemarkConfig<remarkGFMPlugin>',\n  group: 'Remark',\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin } from '@milkdown/ctx'\nimport {\n  autoInsertZeroSpaceInTablePlugin,\n  columnResizingPlugin,\n  remarkGFMPlugin,\n  tableEditingPlugin,\n} from '../plugin'\n\n/// @internal\nexport const plugins: MilkdownPlugin[] = [\n  autoInsertZeroSpaceInTablePlugin,\n  columnResizingPlugin,\n  tableEditingPlugin,\n  remarkGFMPlugin,\n].flat()\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin } from '@milkdown/ctx'\nimport { strikethroughAttr, strikethroughSchema } from '../mark'\nimport { extendListItemSchemaForTask, footnoteDefinitionSchema, footnoteReferenceSchema, tableCellSchema, tableHeaderSchema, tableRowSchema, tableSchema } from '../node'\n\n/// @internal\nexport const schema: MilkdownPlugin[] = [\n  extendListItemSchemaForTask,\n\n  tableSchema,\n  tableRowSchema,\n  tableHeaderSchema,\n  tableCellSchema,\n\n  footnoteDefinitionSchema,\n  footnoteReferenceSchema,\n\n  strikethroughAttr,\n  strikethroughSchema,\n].flat()\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { toggleStrikethroughCommand } from '../mark'\nimport { addColAfterCommand, addColBeforeCommand, addRowAfterCommand, addRowBeforeCommand, breakTableCommand, deleteSelectedCellsCommand, goToNextTableCellCommand, goToPrevTableCellCommand, insertTableCommand, moveColCommand, moveRowCommand, selectColCommand, selectRowCommand, selectTableCommand, setAlignCommand } from '../node'\n\n/// @internal\nexport const commands = [\n  goToNextTableCellCommand,\n  goToPrevTableCellCommand,\n  breakTableCommand,\n  insertTableCommand,\n  moveRowCommand,\n  moveColCommand,\n  selectRowCommand,\n  selectColCommand,\n  selectTableCommand,\n  deleteSelectedCellsCommand,\n  addRowBeforeCommand,\n  addRowAfterCommand,\n  addColBeforeCommand,\n  addColAfterCommand,\n  setAlignCommand,\n\n  toggleStrikethroughCommand,\n]\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { commands, inputRules, keymap, markInputRules, plugins, schema } from './composed'\n\nexport * from './node'\nexport * from './mark'\nexport * from './plugin'\nexport * from './composed'\n\n/// The GFM preset, includes all the plugins.\nexport const gfm = [schema, inputRules, markInputRules, keymap, plugins, commands].flat()\n"],"names":["withMeta","plugin","meta","strikethroughAttr","$markAttr","strikethroughSchema","$markSchema","ctx","value","mark","node","state","markType","toggleStrikethroughCommand","$command","toggleMark","strikethroughInputRule","$inputRule","markRule","strikethroughKeymap","$useKeymap","commands","commandsCtx","createTable","rowsCount","colsCount","cells","tableCellSchema","headerCells","tableHeaderSchema","rows","_","i","tableRowSchema","tableSchema","findTable","selection","findParentNode","getCellsInCol","columnIndex","table","map","TableMap","pos","start","x","getCellsInRow","rowIndex","getAllCellsInTable","nodePos","selectTable","tr","$firstCell","last","$lastCell","cloneTr","CellSelection","addRowWithAlignment","tableStart","row","rowPos","acc","col","headerCol","selectLine","type","index","isRowSelection","lastCell","createCellSelection","firstCell","selectRow","selectCol","transpose","array","column","convertArrayOfRowsToTableNode","tableNode","arrayOfNodes","rowsPM","rowCells","colIndex","cellPos","cell","newCell","convertTableNodeToArrayOfRows","seen","rect","moveRowInArrayOfRows","indexesOrigin","indexesTarget","directionOverride","direction","rowsExtracted","positionOffset","target","moveTableColumn","moveTableRow","getSelectionRangeInColumn","startIndex","endIndex","maybeEndIndex","indexes","maybeCells","firstSelectedColumnCells","firstRowCells","$anchor","headCell","columnCells","j","$head","getSelectionRangeInRow","firstSelectedRowCells","firstColumnCells","moveCol","origin","select","indexesOriginColumn","indexesTargetColumn","newTable","_tr","moveRow","indexesOriginRow","indexesTargetRow","originalSchema","tableNodes","dom","attrs","$nodeSchema","align","children","firstLine","_a","insertTableInputRule","InputRule","match","end","$start","_b","TextSelection","goToPrevTableCellCommand","goToNextCell","goToNextTableCellCommand","breakTableCommand","dispatch","isInTable","paragraphSchema","Selection","insertTableCommand","from","sel","moveRowCommand","to","moveColCommand","selectRowCommand","selectColCommand","selectTableCommand","deleteSelectedCellsCommand","isRow","isCol","deleteTable","deleteColumn","deleteRow","addColBeforeCommand","addColumnBefore","addColAfterCommand","addColumnAfter","addRowBeforeCommand","selectedRect","addRowAfterCommand","setAlignCommand","alignment","setCellAttr","tableKeymap","id","markdownId","footnoteDefinitionSchema","expectDomTypeError","label","footnoteReferenceSchema","extendListItemSchemaForTask","listItemSchema","prev","baseSchema","checked","listType","spread","wrapInTaskListInputRule","depth","finPos","keymap","inputRules","markInputRules","autoInsertZeroSpaceInTablePlugin","$prose","pluginKey","PluginKey","isParagraph","isEmptyParagraph","Plugin","view","$from","browser","columnResizingPlugin","columnResizing","tableEditingPlugin","tableEditing","remarkGFMPlugin","$remark","remarkGFM","plugins","schema","gfm"],"mappings":"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"}