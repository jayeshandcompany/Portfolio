{
  "version": 3,
  "sources": ["../../.pnpm/inline-style-parser@0.2.3/node_modules/inline-style-parser/index.js", "../../.pnpm/style-to-object@1.0.6/node_modules/style-to-object/src/index.ts", "../../.pnpm/estree-util-is-identifier-name@3.0.0/node_modules/estree-util-is-identifier-name/lib/index.js", "../../.pnpm/hast-util-whitespace@3.0.0/node_modules/hast-util-whitespace/lib/index.js", "../../.pnpm/style-to-object@1.0.6/node_modules/style-to-object/esm/index.mjs", "../../.pnpm/unist-util-position@5.0.0/node_modules/unist-util-position/lib/index.js", "../../.pnpm/hast-util-to-jsx-runtime@2.3.0/node_modules/hast-util-to-jsx-runtime/lib/index.js", "../../.pnpm/html-url-attributes@3.0.0/node_modules/html-url-attributes/lib/index.js", "../../.pnpm/react-markdown@9.0.1_@types+react@18.3.1_react@18.3.1/node_modules/react-markdown/lib/index.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/blockquote.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/break.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/code.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/delete.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/emphasis.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/heading.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/html.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/revert.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/image-reference.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/image.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/inline-code.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/link-reference.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/link.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/list-item.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/list.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/paragraph.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/root.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/strong.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/table.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/table-row.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/table-cell.js", "../../.pnpm/trim-lines@3.0.1/node_modules/trim-lines/index.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/text.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/handlers/index.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/footer.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/state.js", "../../.pnpm/mdast-util-to-hast@13.1.0/node_modules/mdast-util-to-hast/lib/index.js", "../../.pnpm/remark-rehype@11.1.0/node_modules/remark-rehype/lib/index.js"],
  "sourcesContent": ["// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nvar NEWLINE_REGEX = /\\n/g;\nvar WHITESPACE_REGEX = /^\\s*/;\n\n// declaration\nvar PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar COLON_REGEX = /^:\\s*/;\nvar VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar SEMICOLON_REGEX = /^[;\\s]*/;\n\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar TRIM_REGEX = /^\\s+|\\s+$/g;\n\n// strings\nvar NEWLINE = '\\n';\nvar FORWARD_SLASH = '/';\nvar ASTERISK = '*';\nvar EMPTY_STRING = '';\n\n// types\nvar TYPE_COMMENT = 'comment';\nvar TYPE_DECLARATION = 'declaration';\n\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */\nmodule.exports = function (style, options) {\n  if (typeof style !== 'string') {\n    throw new TypeError('First argument must be a string');\n  }\n\n  if (!style) return [];\n\n  options = options || {};\n\n  /**\n   * Positional.\n   */\n  var lineno = 1;\n  var column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */\n  function updatePosition(str) {\n    var lines = str.match(NEWLINE_REGEX);\n    if (lines) lineno += lines.length;\n    var i = str.lastIndexOf(NEWLINE);\n    column = ~i ? str.length - i : column + str.length;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */\n  function position() {\n    var start = { line: lineno, column: column };\n    return function (node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */\n  function Position(start) {\n    this.start = start;\n    this.end = { line: lineno, column: column };\n    this.source = options.source;\n  }\n\n  /**\n   * Non-enumerable source string.\n   */\n  Position.prototype.content = style;\n\n  var errorsList = [];\n\n  /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */\n  function error(msg) {\n    var err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = style;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */\n  function match(re) {\n    var m = re.exec(style);\n    if (!m) return;\n    var str = m[0];\n    updatePosition(str);\n    style = style.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n  function whitespace() {\n    match(WHITESPACE_REGEX);\n  }\n\n  /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */\n  function comments(rules) {\n    var c;\n    rules = rules || [];\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function comment() {\n    var pos = position();\n    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;\n\n    var i = 2;\n    while (\n      EMPTY_STRING != style.charAt(i) &&\n      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if (EMPTY_STRING === style.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = style.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    style = style.slice(i);\n    column += 2;\n\n    return pos({\n      type: TYPE_COMMENT,\n      comment: str\n    });\n  }\n\n  /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function declaration() {\n    var pos = position();\n\n    // prop\n    var prop = match(PROPERTY_REGEX);\n    if (!prop) return;\n    comment();\n\n    // :\n    if (!match(COLON_REGEX)) return error(\"property missing ':'\");\n\n    // val\n    var val = match(VALUE_REGEX);\n\n    var ret = pos({\n      type: TYPE_DECLARATION,\n      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),\n      value: val\n        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))\n        : EMPTY_STRING\n    });\n\n    // ;\n    match(SEMICOLON_REGEX);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */\n  function declarations() {\n    var decls = [];\n\n    comments(decls);\n\n    // declarations\n    var decl;\n    while ((decl = declaration())) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n    }\n\n    return decls;\n  }\n\n  whitespace();\n  return declarations();\n};\n\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */\nfunction trim(str) {\n  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;\n}\n", "import parse from 'inline-style-parser';\nimport type { Declaration } from 'inline-style-parser';\n\nexport { Declaration };\n\ninterface StyleObject {\n  [name: string]: string;\n}\n\ntype Iterator = (\n  property: string,\n  value: string,\n  declaration: Declaration,\n) => void;\n\n/**\n * Parses inline style to object.\n *\n * @param style - Inline style.\n * @param iterator - Iterator.\n * @returns - Style object or null.\n *\n * @example Parsing inline style to object:\n *\n * ```js\n * import parse from 'style-to-object';\n * parse('line-height: 42;'); // { 'line-height': '42' }\n * ```\n */\nexport default function StyleToObject(\n  style: string,\n  iterator?: Iterator,\n): StyleObject | null {\n  let styleObject: StyleObject | null = null;\n\n  if (!style || typeof style !== 'string') {\n    return styleObject;\n  }\n\n  const declarations = parse(style);\n  const hasIterator = typeof iterator === 'function';\n\n  declarations.forEach((declaration) => {\n    if (declaration.type !== 'declaration') {\n      return;\n    }\n\n    const { property, value } = declaration;\n\n    if (hasIterator) {\n      iterator(property, value, declaration);\n    } else if (value) {\n      styleObject = styleObject || {};\n      styleObject[property] = value;\n    }\n  });\n\n  return styleObject;\n}\n", "/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [jsx=false]\n *   Support JSX identifiers (default: `false`).\n */\n\nconst startRe = /[$_\\p{ID_Start}]/u\nconst contRe = /[$_\\u{200C}\\u{200D}\\p{ID_Continue}]/u\nconst contReJsx = /[-$_\\u{200C}\\u{200D}\\p{ID_Continue}]/u\nconst nameRe = /^[$_\\p{ID_Start}][$_\\u{200C}\\u{200D}\\p{ID_Continue}]*$/u\nconst nameReJsx = /^[$_\\p{ID_Start}][-$_\\u{200C}\\u{200D}\\p{ID_Continue}]*$/u\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Checks if the given code point can start an identifier.\n *\n * @param {number | undefined} code\n *   Code point to check.\n * @returns {boolean}\n *   Whether `code` can start an identifier.\n */\n// Note: `undefined` is supported so you can pass the result from `''.codePointAt`.\nexport function start(code) {\n  return code ? startRe.test(String.fromCodePoint(code)) : false\n}\n\n/**\n * Checks if the given code point can continue an identifier.\n *\n * @param {number | undefined} code\n *   Code point to check.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {boolean}\n *   Whether `code` can continue an identifier.\n */\n// Note: `undefined` is supported so you can pass the result from `''.codePointAt`.\nexport function cont(code, options) {\n  const settings = options || emptyOptions\n  const re = settings.jsx ? contReJsx : contRe\n  return code ? re.test(String.fromCodePoint(code)) : false\n}\n\n/**\n * Checks if the given value is a valid identifier name.\n *\n * @param {string} name\n *   Identifier to check.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {boolean}\n *   Whether `name` can be an identifier.\n */\nexport function name(name, options) {\n  const settings = options || emptyOptions\n  const re = settings.jsx ? nameReJsx : nameRe\n  return re.test(name)\n}\n", "/**\n * @typedef {import('hast').Nodes} Nodes\n */\n\n// HTML whitespace expression.\n// See <https://infra.spec.whatwg.org/#ascii-whitespace>.\nconst re = /[ \\t\\n\\f\\r]/g\n\n/**\n * Check if the given value is *inter-element whitespace*.\n *\n * @param {Nodes | string} thing\n *   Thing to check (`Node` or `string`).\n * @returns {boolean}\n *   Whether the `value` is inter-element whitespace (`boolean`): consisting of\n *   zero or more of space, tab (`\\t`), line feed (`\\n`), carriage return\n *   (`\\r`), or form feed (`\\f`); if a node is passed it must be a `Text` node,\n *   whose `value` field is checked.\n */\nexport function whitespace(thing) {\n  return typeof thing === 'object'\n    ? thing.type === 'text'\n      ? empty(thing.value)\n      : false\n    : empty(thing)\n}\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nfunction empty(value) {\n  return value.replace(re, '') === ''\n}\n", "import StyleToObject from '../cjs/index.js';\n\n// ensure compatibility with rollup umd build\nexport default StyleToObject.default || StyleToObject;\n", "/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Get the ending point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointEnd = point('end')\n\n/**\n * Get the starting point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointStart = point('start')\n\n/**\n * Get the positional info of `node`.\n *\n * @param {'end' | 'start'} type\n *   Side.\n * @returns\n *   Getter.\n */\nfunction point(type) {\n  return point\n\n  /**\n   * Get the point info of `node` at a bound side.\n   *\n   * @param {Node | NodeLike | null | undefined} [node]\n   * @returns {Point | undefined}\n   */\n  function point(node) {\n    const point = (node && node.position && node.position[type]) || {}\n\n    if (\n      typeof point.line === 'number' &&\n      point.line > 0 &&\n      typeof point.column === 'number' &&\n      point.column > 0\n    ) {\n      return {\n        line: point.line,\n        column: point.column,\n        offset:\n          typeof point.offset === 'number' && point.offset > -1\n            ? point.offset\n            : undefined\n      }\n    }\n  }\n}\n\n/**\n * Get the positional info of `node`.\n *\n * @param {Node | NodeLike | null | undefined} [node]\n *   Node.\n * @returns {Position | undefined}\n *   Position.\n */\nexport function position(node) {\n  const start = pointStart(node)\n  const end = pointEnd(node)\n\n  if (start && end) {\n    return {start, end}\n  }\n}\n", "// Register MDX nodes in mdast:\n/// <reference types=\"mdast-util-mdx-expression\" />\n/// <reference types=\"mdast-util-mdx-jsx\" />\n/// <reference types=\"mdast-util-mdxjs-esm\" />\n\n/**\n * @typedef {import('estree').Identifier} Identifier\n * @typedef {import('estree').Literal} Literal\n * @typedef {import('estree').MemberExpression} MemberExpression\n * @typedef {import('estree').Expression} Expression\n * @typedef {import('estree').Program} Program\n *\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('mdast-util-mdx-expression').MdxFlowExpressionHast} MdxFlowExpression\n * @typedef {import('mdast-util-mdx-expression').MdxTextExpressionHast} MdxTextExpression\n *\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxFlowElementHast} MdxJsxFlowElement\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxTextElementHast} MdxJsxTextElement\n *\n * @typedef {import('mdast-util-mdxjs-esm').MdxjsEsmHast} MdxjsEsm\n *\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {import('unist').Position} Position\n *\n * @typedef {import('./components.js').Components} Components\n */\n\n/**\n * @typedef {JSX.Element | string | null | undefined} Child\n *   Child.\n *\n * @callback Create\n *   Create something in development or production.\n * @param {Nodes} node\n *   hast node.\n * @param {unknown} type\n *   Fragment symbol or tag name.\n * @param {Props} props\n *   Properties and children.\n * @param {string | undefined} key\n *   Key.\n * @returns {JSX.Element}\n *   Result.\n *\n * @callback CreateEvaluater\n *   Create an evaluator that turns ESTree ASTs from embedded MDX into values.\n * @returns {Evaluater}\n *   Evaluater.\n *\n * @typedef {'html' | 'react'} ElementAttributeNameCase\n *   Casing to use for attribute names.\n *\n *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`.\n *   React casing is for example `className`, `strokeLinecap`, `xmlLang`.\n *\n * @callback EvaluateExpression\n *   Turn an MDX expression into a value.\n * @param {Expression} expression\n *   ESTree expression.\n * @returns {unknown}\n *   Result of expression.\n *\n * @callback EvaluateProgram\n *   Turn an MDX program (export/import statements) into a value.\n * @param {Program} expression\n *   ESTree program.\n * @returns {unknown}\n *   Result of program;\n *   should likely be `undefined` as ESM changes the scope but doesn’t yield\n *   something.\n *\n * @typedef Evaluater\n *   Evaluator that turns ESTree ASTs from embedded MDX into values.\n * @property {EvaluateExpression} evaluateExpression\n *   Evaluate an expression.\n * @property {EvaluateProgram} evaluateProgram\n *   Evaluate a program.\n *\n * @typedef {[string, Value]} Field\n *   Property field.\n *\n * @typedef {unknown} Fragment\n *   Represent the children, typically a symbol.\n *\n * @callback Jsx\n *   Create a production element.\n * @param {unknown} type\n *   Element type: `Fragment` symbol, tag name (`string`), component.\n * @param {Props} props\n *   Element props, `children`, and maybe `node`.\n * @param {string | undefined} [key]\n *   Dynamicly generated key to use.\n * @returns {JSX.Element}\n *   Element from your framework.\n *\n * @callback JsxDev\n *   Create a development element.\n * @param {unknown} type\n *   Element type: `Fragment` symbol, tag name (`string`), component.\n * @param {Props} props\n *   Element props, `children`, and maybe `node`.\n * @param {string | undefined} key\n *   Dynamicly generated key to use.\n * @param {boolean} isStaticChildren\n *   Whether two or more children are passed (in an array), which is whether\n *   `jsxs` or `jsx` would be used.\n * @param {Source} source\n *   Info about source.\n * @param {undefined} self\n *   Nothing (this is used by frameworks that have components, we don’t).\n * @returns {JSX.Element}\n *   Element from your framework.\n *\n * @typedef {{children?: Array<Child> | Child, node?: Element | MdxJsxFlowElement | MdxJsxTextElement | undefined, [prop: string]: Array<Child> | Child | Element | MdxJsxFlowElement | MdxJsxTextElement | Value | undefined}} Props\n *   Properties and children.\n *\n * @typedef RegularFields\n *   Configuration.\n * @property {Partial<Components> | null | undefined} [components]\n *   Components to use (optional).\n * @property {CreateEvaluater | null | undefined} [createEvaluater]\n *   Create an evaluator that turns ESTree ASTs into values (optional).\n * @property {ElementAttributeNameCase | null | undefined} [elementAttributeNameCase='react']\n *   Specify casing to use for attribute names (default: `'react'`).\n * @property {string | null | undefined} [filePath]\n *   File path to the original source file (optional).\n *\n *   Passed in source info to `jsxDEV` when using the automatic runtime with\n *   `development: true`.\n * @property {boolean | null | undefined} [ignoreInvalidStyle=false]\n *   Ignore invalid CSS in `style` props (default: `false`);\n *   the default behavior is to throw an error.\n * @property {boolean | null | undefined} [passKeys=true]\n *   Generate keys to optimize frameworks that support them (default: `true`).\n *\n *   > 👉 **Note**: Solid currently fails if keys are passed.\n * @property {boolean | null | undefined} [passNode=false]\n *   Pass the hast element node to components (default: `false`).\n * @property {Space | null | undefined} [space='html']\n *   Whether `tree` is in the `'html'` or `'svg'` space (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {StylePropertyNameCase | null | undefined} [stylePropertyNameCase='dom']\n *   Specify casing to use for property names in `style` objects (default:\n *   `'dom'`).\n * @property {boolean | null | undefined} [tableCellAlignToStyle=true]\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props\n *   (default: `true`).\n *\n * @typedef RuntimeDevelopment\n *   Runtime fields when development is on.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {true} development\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\n * @property {Jsx | null | undefined} [jsx]\n *   Dynamic JSX (optional).\n * @property {JsxDev} jsxDEV\n *   Development JSX.\n * @property {Jsx | null | undefined} [jsxs]\n *   Static JSX (optional).\n *\n * @typedef RuntimeProduction\n *   Runtime fields when development is off.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {false | null | undefined} [development]\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off) (optional).\n * @property {Jsx} jsx\n *   Dynamic JSX.\n * @property {JsxDev | null | undefined} [jsxDEV]\n *   Development JSX (optional).\n * @property {Jsx} jsxs\n *   Static JSX.\n *\n * @typedef RuntimeUnknown\n *   Runtime fields when development might be on or off.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {boolean} development\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\n * @property {Jsx | null | undefined} [jsx]\n *   Dynamic JSX (optional).\n * @property {JsxDev | null | undefined} [jsxDEV]\n *   Development JSX (optional).\n * @property {Jsx | null | undefined} [jsxs]\n *   Static JSX (optional).\n *\n * @typedef Source\n *   Info about source.\n * @property {number | undefined} columnNumber\n *   Column where thing starts (0-indexed).\n * @property {string | undefined} fileName\n *   Name of source file.\n * @property {number | undefined} lineNumber\n *   Line where thing starts (1-indexed).\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n *   > 👉 **Note**: hast is not XML.\n *   > It supports SVG as embedded in HTML.\n *   > It does not support the features available in XML.\n *   > Passing SVG might break but fragments of modern SVG should be fine.\n *   > Use `xast` if you need to support SVG as XML.\n *\n * @typedef State\n *   Info passed around.\n * @property {unknown} Fragment\n *   Fragment symbol.\n * @property {Array<Parents>} ancestors\n *   Stack of parents.\n * @property {Partial<Components>} components\n *   Components to swap.\n * @property {Create} create\n *   Create something in development or production.\n * @property {ElementAttributeNameCase} elementAttributeNameCase\n *   Casing to use for attribute names.\n * @property {Evaluater | undefined} evaluater\n *   Evaluator that turns ESTree ASTs into values.\n * @property {string | undefined} filePath\n *   File path.\n * @property {boolean} ignoreInvalidStyle\n *   Ignore invalid CSS in `style` props.\n * @property {boolean} passKeys\n *   Generate keys to optimize frameworks that support them.\n * @property {boolean} passNode\n *   Pass `node` to components.\n * @property {Schema} schema\n *   Current schema.\n * @property {StylePropertyNameCase} stylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n * @property {boolean} tableCellAlignToStyle\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props.\n *\n * @typedef {Record<string, string>} Style\n *   Style map.\n *\n * @typedef {'css' | 'dom'} StylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n *\n *   CSS casing is for example `background-color` and `-webkit-line-clamp`.\n *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`.\n *\n * @typedef {Style | boolean | number | string} Value\n *   Primitive property value and `Style` map.\n */\n\n/**\n * @typedef {RuntimeDevelopment & RegularFields} Development\n *   Configuration (development).\n * @typedef {Development | Production | Unknown} Options\n *   Configuration.\n * @typedef {RegularFields & RuntimeProduction} Production\n *   Configuration (production).\n * @typedef {RegularFields & RuntimeUnknown} Unknown\n *   Configuration (production or development).\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {ok as assert} from 'devlop'\nimport {name as isIdentifierName} from 'estree-util-is-identifier-name'\nimport {whitespace} from 'hast-util-whitespace'\nimport {find, hastToReact, html, svg} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport styleToObject from 'style-to-object'\nimport {pointStart} from 'unist-util-position'\nimport {VFileMessage} from 'vfile-message'\n\nconst own = {}.hasOwnProperty\n\n/** @type {Map<string, number>} */\nconst emptyMap = new Map()\n\nconst cap = /[A-Z]/g\nconst dashSomething = /-([a-z])/g\n\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they don’t do here, so we remove all of\n// that.\n\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\nconst tableElements = new Set(['table', 'tbody', 'thead', 'tfoot', 'tr'])\n\nconst tableCellElement = new Set(['td', 'th'])\n\nconst docs = 'https://github.com/syntax-tree/hast-util-to-jsx-runtime'\n\n/**\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\n * with an automatic JSX runtime.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options} options\n *   Configuration (required).\n * @returns {JSX.Element}\n *   JSX element.\n */\n\nexport function toJsxRuntime(tree, options) {\n  if (!options || options.Fragment === undefined) {\n    throw new TypeError('Expected `Fragment` in options')\n  }\n\n  const filePath = options.filePath || undefined\n  /** @type {Create} */\n  let create\n\n  if (options.development) {\n    if (typeof options.jsxDEV !== 'function') {\n      throw new TypeError(\n        'Expected `jsxDEV` in options when `development: true`'\n      )\n    }\n\n    create = developmentCreate(filePath, options.jsxDEV)\n  } else {\n    if (typeof options.jsx !== 'function') {\n      throw new TypeError('Expected `jsx` in production options')\n    }\n\n    if (typeof options.jsxs !== 'function') {\n      throw new TypeError('Expected `jsxs` in production options')\n    }\n\n    create = productionCreate(filePath, options.jsx, options.jsxs)\n  }\n\n  /** @type {State} */\n  const state = {\n    Fragment: options.Fragment,\n    ancestors: [],\n    components: options.components || {},\n    create,\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\n    evaluater: options.createEvaluater ? options.createEvaluater() : undefined,\n    filePath,\n    ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n    passKeys: options.passKeys !== false,\n    passNode: options.passNode || false,\n    schema: options.space === 'svg' ? svg : html,\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\n    tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n  }\n\n  const result = one(state, tree, undefined)\n\n  // JSX element.\n  if (result && typeof result !== 'string') {\n    return result\n  }\n\n  // Text node or something that turned into nothing.\n  return state.create(\n    tree,\n    state.Fragment,\n    {children: result || undefined},\n    undefined\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction one(state, node, key) {\n  if (node.type === 'element') {\n    return element(state, node, key)\n  }\n\n  if (node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression') {\n    return mdxExpression(state, node)\n  }\n\n  if (node.type === 'mdxJsxFlowElement' || node.type === 'mdxJsxTextElement') {\n    return mdxJsxElement(state, node, key)\n  }\n\n  if (node.type === 'mdxjsEsm') {\n    return mdxEsm(state, node)\n  }\n\n  if (node.type === 'root') {\n    return root(state, node, key)\n  }\n\n  if (node.type === 'text') {\n    return text(state, node)\n  }\n}\n\n/**\n * Handle element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction element(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\n    schema = svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type = findComponentFromName(state, node.tagName, false)\n  const props = createElementProps(state, node)\n  let children = createChildren(state, node)\n\n  if (tableElements.has(node.tagName)) {\n    children = children.filter(function (child) {\n      return typeof child === 'string' ? !whitespace(child) : true\n    })\n  }\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle MDX expression.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxFlowExpression | MdxTextExpression} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxExpression(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    const program = node.data.estree\n    const expression = program.body[0]\n    assert(expression.type === 'ExpressionStatement')\n\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateExpression(expression.expression)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX ESM.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxjsEsm} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxEsm(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateProgram(node.data.estree)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX JSX.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxJsxElement(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.name === 'svg' && parentSchema.space === 'html') {\n    schema = svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type =\n    node.name === null\n      ? state.Fragment\n      : findComponentFromName(state, node.name, true)\n  const props = createJsxElementProps(state, node)\n  const children = createChildren(state, node)\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Root} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction root(state, node, key) {\n  /** @type {Props} */\n  const props = {}\n\n  addChildren(props, createChildren(state, node))\n\n  return state.create(node, state.Fragment, props, key)\n}\n\n/**\n * Handle text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Text} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction text(_, node) {\n  return node.value\n}\n\n/**\n * Add `node` to props.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Props} props\n *   Props.\n * @param {unknown} type\n *   Type.\n * @param {Element | MdxJsxFlowElement | MdxJsxTextElement} node\n *   Node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addNode(state, props, type, node) {\n  // If this is swapped out for a component:\n  if (typeof type !== 'string' && type !== state.Fragment && state.passNode) {\n    props.node = node\n  }\n}\n\n/**\n * Add children to props.\n *\n * @param {Props} props\n *   Props.\n * @param {Array<Child>} children\n *   Children.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChildren(props, children) {\n  if (children.length > 0) {\n    const value = children.length > 1 ? children : children[0]\n\n    if (value) {\n      props.children = value\n    }\n  }\n}\n\n/**\n * @param {string | undefined} _\n *   Path to file.\n * @param {Jsx} jsx\n *   Dynamic.\n * @param {Jsx} jsxs\n *   Static.\n * @returns {Create}\n *   Create a production element.\n */\nfunction productionCreate(_, jsx, jsxs) {\n  return create\n  /** @type {Create} */\n  function create(_, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const fn = isStaticChildren ? jsxs : jsx\n    return key ? fn(type, props, key) : fn(type, props)\n  }\n}\n\n/**\n * @param {string | undefined} filePath\n *   Path to file.\n * @param {JsxDev} jsxDEV\n *   Development.\n * @returns {Create}\n *   Create a development element.\n */\nfunction developmentCreate(filePath, jsxDEV) {\n  return create\n  /** @type {Create} */\n  function create(node, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const point = pointStart(node)\n    return jsxDEV(\n      type,\n      props,\n      key,\n      isStaticChildren,\n      {\n        columnNumber: point ? point.column - 1 : undefined,\n        fileName: filePath,\n        lineNumber: point ? point.line : undefined\n      },\n      undefined\n    )\n  }\n}\n\n/**\n * Create props from an element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current element.\n * @returns {Props}\n *   Props.\n */\nfunction createElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n  /** @type {string | undefined} */\n  let alignValue\n  /** @type {string} */\n  let prop\n\n  for (prop in node.properties) {\n    if (prop !== 'children' && own.call(node.properties, prop)) {\n      const result = createProperty(state, prop, node.properties[prop])\n\n      if (result) {\n        const [key, value] = result\n\n        if (\n          state.tableCellAlignToStyle &&\n          key === 'align' &&\n          typeof value === 'string' &&\n          tableCellElement.has(node.tagName)\n        ) {\n          alignValue = value\n        } else {\n          props[key] = value\n        }\n      }\n    }\n  }\n\n  if (alignValue) {\n    // Assume style is an object.\n    const style = /** @type {Style} */ (props.style || (props.style = {}))\n    style[state.stylePropertyNameCase === 'css' ? 'text-align' : 'textAlign'] =\n      alignValue\n  }\n\n  return props\n}\n\n/**\n * Create props from a JSX element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n *   Current JSX element.\n * @returns {Props}\n *   Props.\n */\nfunction createJsxElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n\n  for (const attribute of node.attributes) {\n    if (attribute.type === 'mdxJsxExpressionAttribute') {\n      if (attribute.data && attribute.data.estree && state.evaluater) {\n        const program = attribute.data.estree\n        const expression = program.body[0]\n        assert(expression.type === 'ExpressionStatement')\n        const objectExpression = expression.expression\n        assert(objectExpression.type === 'ObjectExpression')\n        const property = objectExpression.properties[0]\n        assert(property.type === 'SpreadElement')\n\n        Object.assign(\n          props,\n          state.evaluater.evaluateExpression(property.argument)\n        )\n      } else {\n        crashEstree(state, node.position)\n      }\n    } else {\n      // For JSX, the author is responsible of passing in the correct values.\n      const name = attribute.name\n      /** @type {unknown} */\n      let value\n\n      if (attribute.value && typeof attribute.value === 'object') {\n        if (\n          attribute.value.data &&\n          attribute.value.data.estree &&\n          state.evaluater\n        ) {\n          const program = attribute.value.data.estree\n          const expression = program.body[0]\n          assert(expression.type === 'ExpressionStatement')\n          value = state.evaluater.evaluateExpression(expression.expression)\n        } else {\n          crashEstree(state, node.position)\n        }\n      } else {\n        value = attribute.value === null ? true : attribute.value\n      }\n\n      // Assume a prop.\n      props[name] = /** @type {Props[keyof Props]} */ (value)\n    }\n  }\n\n  return props\n}\n\n/**\n * Create children.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Parents} node\n *   Current element.\n * @returns {Array<Child>}\n *   Children.\n */\nfunction createChildren(state, node) {\n  /** @type {Array<Child>} */\n  const children = []\n  let index = -1\n  /** @type {Map<string, number>} */\n  // Note: test this when Solid doesn’t want to merge my upcoming PR.\n  /* c8 ignore next */\n  const countsByName = state.passKeys ? new Map() : emptyMap\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n    /** @type {string | undefined} */\n    let key\n\n    if (state.passKeys) {\n      const name =\n        child.type === 'element'\n          ? child.tagName\n          : child.type === 'mdxJsxFlowElement' ||\n              child.type === 'mdxJsxTextElement'\n            ? child.name\n            : undefined\n\n      if (name) {\n        const count = countsByName.get(name) || 0\n        key = name + '-' + count\n        countsByName.set(name, count + 1)\n      }\n    }\n\n    const result = one(state, child, key)\n    if (result !== undefined) children.push(result)\n  }\n\n  return children\n}\n\n/**\n * Handle a property.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Field | undefined}\n *   Field for runtime, optional.\n */\nfunction createProperty(state, prop, value) {\n  const info = find(state.schema, prop)\n\n  // Ignore nullish and `NaN` values.\n  if (\n    value === null ||\n    value === undefined ||\n    (typeof value === 'number' && Number.isNaN(value))\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value)\n  }\n\n  // React only accepts `style` as object.\n  if (info.property === 'style') {\n    let styleObject =\n      typeof value === 'object' ? value : parseStyle(state, String(value))\n\n    if (state.stylePropertyNameCase === 'css') {\n      styleObject = transformStylesToCssCasing(styleObject)\n    }\n\n    return ['style', styleObject]\n  }\n\n  return [\n    state.elementAttributeNameCase === 'react' && info.space\n      ? hastToReact[info.property] || info.property\n      : info.attribute,\n    value\n  ]\n}\n\n/**\n * Parse a CSS declaration to an object.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} value\n *   CSS declarations.\n * @returns {Style}\n *   Properties.\n * @throws\n *   Throws `VFileMessage` when CSS cannot be parsed.\n */\nfunction parseStyle(state, value) {\n  /** @type {Style} */\n  const result = {}\n\n  try {\n    // @ts-expect-error: `style-to-object` types are broken.\n    styleToObject(value, replacer)\n  } catch (error) {\n    if (!state.ignoreInvalidStyle) {\n      const cause = /** @type {Error} */ (error)\n      const message = new VFileMessage('Cannot parse `style` attribute', {\n        ancestors: state.ancestors,\n        cause,\n        ruleId: 'style',\n        source: 'hast-util-to-jsx-runtime'\n      })\n      message.file = state.filePath || undefined\n      message.url = docs + '#cannot-parse-style-attribute'\n\n      throw message\n    }\n  }\n\n  return result\n\n  /**\n   * Add a CSS property (normal, so with dashes) to `result` as a DOM CSS\n   * property.\n   *\n   * @param {string} name\n   *   Key.\n   * @param {string} value\n   *   Value\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function replacer(name, value) {\n    let key = name\n\n    if (key.slice(0, 2) !== '--') {\n      if (key.slice(0, 4) === '-ms-') key = 'ms-' + key.slice(4)\n      key = key.replace(dashSomething, toCamel)\n    }\n\n    result[key] = value\n  }\n}\n\n/**\n * Create a JSX name from a string.\n *\n * @param {State} state\n *   To do.\n * @param {string} name\n *   Name.\n * @param {boolean} allowExpression\n *   Allow member expressions and identifiers.\n * @returns {unknown}\n *   To do.\n */\nfunction findComponentFromName(state, name, allowExpression) {\n  /** @type {Identifier | Literal | MemberExpression} */\n  let result\n\n  if (!allowExpression) {\n    result = {type: 'Literal', value: name}\n  } else if (name.includes('.')) {\n    const identifiers = name.split('.')\n    let index = -1\n    /** @type {Identifier | Literal | MemberExpression | undefined} */\n    let node\n\n    while (++index < identifiers.length) {\n      /** @type {Identifier | Literal} */\n      const prop = isIdentifierName(identifiers[index])\n        ? {type: 'Identifier', name: identifiers[index]}\n        : {type: 'Literal', value: identifiers[index]}\n      node = node\n        ? {\n            type: 'MemberExpression',\n            object: node,\n            property: prop,\n            computed: Boolean(index && prop.type === 'Literal'),\n            optional: false\n          }\n        : prop\n    }\n\n    assert(node, 'always a result')\n    result = node\n  } else {\n    result =\n      isIdentifierName(name) && !/^[a-z]/.test(name)\n        ? {type: 'Identifier', name}\n        : {type: 'Literal', value: name}\n  }\n\n  // Only literals can be passed in `components` currently.\n  // No identifiers / member expressions.\n  if (result.type === 'Literal') {\n    const name = /** @type {keyof JSX.IntrinsicElements} */ (result.value)\n\n    return own.call(state.components, name) ? state.components[name] : name\n  }\n\n  // Assume component.\n  if (state.evaluater) {\n    return state.evaluater.evaluateExpression(result)\n  }\n\n  crashEstree(state)\n}\n\n/**\n * @param {State} state\n * @param {Position | undefined} [place]\n * @returns {never}\n */\nfunction crashEstree(state, place) {\n  const message = new VFileMessage(\n    'Cannot handle MDX estrees without `createEvaluater`',\n    {\n      ancestors: state.ancestors,\n      place,\n      ruleId: 'mdx-estree',\n      source: 'hast-util-to-jsx-runtime'\n    }\n  )\n  message.file = state.filePath || undefined\n  message.url = docs + '#cannot-handle-mdx-estrees-without-createevaluater'\n\n  throw message\n}\n\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */\nfunction transformStylesToCssCasing(domCasing) {\n  /** @type {Style} */\n  const cssCasing = {}\n  /** @type {string} */\n  let from\n\n  for (from in domCasing) {\n    if (own.call(domCasing, from)) {\n      cssCasing[transformStyleToCssCasing(from)] = domCasing[from]\n    }\n  }\n\n  return cssCasing\n}\n\n/**\n * Transform a DOM casing style field to a CSS casing style field.\n *\n * @param {string} from\n * @returns {string}\n */\nfunction transformStyleToCssCasing(from) {\n  let to = from.replace(cap, toDash)\n  // Handle `ms-xxx` -> `-ms-xxx`.\n  if (to.slice(0, 3) === 'ms-') to = '-' + to\n  return to\n}\n\n/**\n * Make `$1` capitalized.\n *\n * @param {string} _\n *   Whatever.\n * @param {string} $1\n *   Single ASCII alphabetical.\n * @returns {string}\n *   Capitalized `$1`.\n */\nfunction toCamel(_, $1) {\n  return $1.toUpperCase()\n}\n\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */\nfunction toDash($0) {\n  return '-' + $0.toLowerCase()\n}\n", "/**\n * HTML URL properties.\n *\n * Each key is a property name and each value is a list of tag names it applies\n * to or `null` if it applies to all elements.\n *\n * @type {Record<string, Array<string> | null>}\n */\nexport const urlAttributes = {\n  action: ['form'],\n  cite: ['blockquote', 'del', 'ins', 'q'],\n  data: ['object'],\n  formAction: ['button', 'input'],\n  href: ['a', 'area', 'base', 'link'],\n  icon: ['menuitem'],\n  itemId: null,\n  manifest: ['html'],\n  ping: ['a', 'area'],\n  poster: ['video'],\n  src: [\n    'audio',\n    'embed',\n    'iframe',\n    'img',\n    'input',\n    'script',\n    'source',\n    'track',\n    'video'\n  ]\n}\n", "// Register `Raw` in tree:\n/// <reference types=\"mdast-util-to-hast\" />\n\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast-util-to-jsx-runtime').Components} JsxRuntimeComponents\n * @typedef {import('remark-rehype').Options} RemarkRehypeOptions\n * @typedef {import('unist-util-visit').BuildVisitor<Root>} Visitor\n * @typedef {import('unified').PluggableList} PluggableList\n */\n\n/**\n * @callback AllowElement\n *   Filter elements.\n * @param {Readonly<Element>} element\n *   Element to check.\n * @param {number} index\n *   Index of `element` in `parent`.\n * @param {Readonly<Parents> | undefined} parent\n *   Parent of `element`.\n * @returns {boolean | null | undefined}\n *   Whether to allow `element` (default: `false`).\n *\n * @typedef {Partial<JsxRuntimeComponents>} Components\n *   Map tag names to components.\n *\n * @typedef Deprecation\n *   Deprecation.\n * @property {string} from\n *   Old field.\n * @property {string} id\n *   ID in readme.\n * @property {keyof Options} [to]\n *   New field.\n *\n * @typedef Options\n *   Configuration.\n * @property {AllowElement | null | undefined} [allowElement]\n *   Filter elements (optional);\n *   `allowedElements` / `disallowedElements` is used first.\n * @property {ReadonlyArray<string> | null | undefined} [allowedElements]\n *   Tag names to allow (default: all tag names);\n *   cannot combine w/ `disallowedElements`.\n * @property {string | null | undefined} [children]\n *   Markdown.\n * @property {string | null | undefined} [className]\n *   Wrap in a `div` with this class name.\n * @property {Components | null | undefined} [components]\n *   Map tag names to components.\n * @property {ReadonlyArray<string> | null | undefined} [disallowedElements]\n *   Tag names to disallow (default: `[]`);\n *   cannot combine w/ `allowedElements`.\n * @property {PluggableList | null | undefined} [rehypePlugins]\n *   List of rehype plugins to use.\n * @property {PluggableList | null | undefined} [remarkPlugins]\n *   List of remark plugins to use.\n * @property {Readonly<RemarkRehypeOptions> | null | undefined} [remarkRehypeOptions]\n *   Options to pass through to `remark-rehype`.\n * @property {boolean | null | undefined} [skipHtml=false]\n *   Ignore HTML in markdown completely (default: `false`).\n * @property {boolean | null | undefined} [unwrapDisallowed=false]\n *   Extract (unwrap) what’s in disallowed elements (default: `false`);\n *   normally when say `strong` is not allowed, it and it’s children are dropped,\n *   with `unwrapDisallowed` the element itself is replaced by its children.\n * @property {UrlTransform | null | undefined} [urlTransform]\n *   Change URLs (default: `defaultUrlTransform`)\n *\n * @callback UrlTransform\n *   Transform all URLs.\n * @param {string} url\n *   URL.\n * @param {string} key\n *   Property name (example: `'href'`).\n * @param {Readonly<Element>} node\n *   Node.\n * @returns {string | null | undefined}\n *   Transformed URL (optional).\n */\n\nimport {unreachable} from 'devlop'\nimport {toJsxRuntime} from 'hast-util-to-jsx-runtime'\nimport {urlAttributes} from 'html-url-attributes'\n// @ts-expect-error: untyped.\nimport {Fragment, jsx, jsxs} from 'react/jsx-runtime'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport {unified} from 'unified'\nimport {visit} from 'unist-util-visit'\nimport {VFile} from 'vfile'\n\nconst changelog =\n  'https://github.com/remarkjs/react-markdown/blob/main/changelog.md'\n\n/** @type {PluggableList} */\nconst emptyPlugins = []\n/** @type {Readonly<RemarkRehypeOptions>} */\nconst emptyRemarkRehypeOptions = {allowDangerousHtml: true}\nconst safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i\n\n// Mutable because we `delete` any time it’s used and a message is sent.\n/** @type {ReadonlyArray<Readonly<Deprecation>>} */\nconst deprecations = [\n  {from: 'astPlugins', id: 'remove-buggy-html-in-markdown-parser'},\n  {from: 'allowDangerousHtml', id: 'remove-buggy-html-in-markdown-parser'},\n  {\n    from: 'allowNode',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes',\n    to: 'allowElement'\n  },\n  {\n    from: 'allowedTypes',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes',\n    to: 'allowedElements'\n  },\n  {\n    from: 'disallowedTypes',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes',\n    to: 'disallowedElements'\n  },\n  {from: 'escapeHtml', id: 'remove-buggy-html-in-markdown-parser'},\n  {from: 'includeElementIndex', id: '#remove-includeelementindex'},\n  {\n    from: 'includeNodeIndex',\n    id: 'change-includenodeindex-to-includeelementindex'\n  },\n  {from: 'linkTarget', id: 'remove-linktarget'},\n  {from: 'plugins', id: 'change-plugins-to-remarkplugins', to: 'remarkPlugins'},\n  {from: 'rawSourcePos', id: '#remove-rawsourcepos'},\n  {from: 'renderers', id: 'change-renderers-to-components', to: 'components'},\n  {from: 'source', id: 'change-source-to-children', to: 'children'},\n  {from: 'sourcePos', id: '#remove-sourcepos'},\n  {from: 'transformImageUri', id: '#add-urltransform', to: 'urlTransform'},\n  {from: 'transformLinkUri', id: '#add-urltransform', to: 'urlTransform'}\n]\n\n/**\n * Component to render markdown.\n *\n * @param {Readonly<Options>} options\n *   Props.\n * @returns {JSX.Element}\n *   React element.\n */\nexport function Markdown(options) {\n  const allowedElements = options.allowedElements\n  const allowElement = options.allowElement\n  const children = options.children || ''\n  const className = options.className\n  const components = options.components\n  const disallowedElements = options.disallowedElements\n  const rehypePlugins = options.rehypePlugins || emptyPlugins\n  const remarkPlugins = options.remarkPlugins || emptyPlugins\n  const remarkRehypeOptions = options.remarkRehypeOptions\n    ? {...options.remarkRehypeOptions, ...emptyRemarkRehypeOptions}\n    : emptyRemarkRehypeOptions\n  const skipHtml = options.skipHtml\n  const unwrapDisallowed = options.unwrapDisallowed\n  const urlTransform = options.urlTransform || defaultUrlTransform\n\n  const processor = unified()\n    .use(remarkParse)\n    .use(remarkPlugins)\n    .use(remarkRehype, remarkRehypeOptions)\n    .use(rehypePlugins)\n\n  const file = new VFile()\n\n  if (typeof children === 'string') {\n    file.value = children\n  } else {\n    unreachable(\n      'Unexpected value `' +\n        children +\n        '` for `children` prop, expected `string`'\n    )\n  }\n\n  if (allowedElements && disallowedElements) {\n    unreachable(\n      'Unexpected combined `allowedElements` and `disallowedElements`, expected one or the other'\n    )\n  }\n\n  for (const deprecation of deprecations) {\n    if (Object.hasOwn(options, deprecation.from)) {\n      unreachable(\n        'Unexpected `' +\n          deprecation.from +\n          '` prop, ' +\n          (deprecation.to\n            ? 'use `' + deprecation.to + '` instead'\n            : 'remove it') +\n          ' (see <' +\n          changelog +\n          '#' +\n          deprecation.id +\n          '> for more info)'\n      )\n    }\n  }\n\n  const mdastTree = processor.parse(file)\n  /** @type {Nodes} */\n  let hastTree = processor.runSync(mdastTree, file)\n\n  // Wrap in `div` if there’s a class name.\n  if (className) {\n    hastTree = {\n      type: 'element',\n      tagName: 'div',\n      properties: {className},\n      // Assume no doctypes.\n      children: /** @type {Array<ElementContent>} */ (\n        hastTree.type === 'root' ? hastTree.children : [hastTree]\n      )\n    }\n  }\n\n  visit(hastTree, transform)\n\n  return toJsxRuntime(hastTree, {\n    Fragment,\n    components,\n    ignoreInvalidStyle: true,\n    jsx,\n    jsxs,\n    passKeys: true,\n    passNode: true\n  })\n\n  /** @type {Visitor} */\n  function transform(node, index, parent) {\n    if (node.type === 'raw' && parent && typeof index === 'number') {\n      if (skipHtml) {\n        parent.children.splice(index, 1)\n      } else {\n        parent.children[index] = {type: 'text', value: node.value}\n      }\n\n      return index\n    }\n\n    if (node.type === 'element') {\n      /** @type {string} */\n      let key\n\n      for (key in urlAttributes) {\n        if (\n          Object.hasOwn(urlAttributes, key) &&\n          Object.hasOwn(node.properties, key)\n        ) {\n          const value = node.properties[key]\n          const test = urlAttributes[key]\n          if (test === null || test.includes(node.tagName)) {\n            node.properties[key] = urlTransform(String(value || ''), key, node)\n          }\n        }\n      }\n    }\n\n    if (node.type === 'element') {\n      let remove = allowedElements\n        ? !allowedElements.includes(node.tagName)\n        : disallowedElements\n        ? disallowedElements.includes(node.tagName)\n        : false\n\n      if (!remove && allowElement && typeof index === 'number') {\n        remove = !allowElement(node, index, parent)\n      }\n\n      if (remove && parent && typeof index === 'number') {\n        if (unwrapDisallowed && node.children) {\n          parent.children.splice(index, 1, ...node.children)\n        } else {\n          parent.children.splice(index, 1)\n        }\n\n        return index\n      }\n    }\n  }\n}\n\n/**\n * Make a URL safe.\n *\n * @satisfies {UrlTransform}\n * @param {string} value\n *   URL.\n * @returns {string}\n *   Safe URL.\n */\nexport function defaultUrlTransform(value) {\n  // Same as:\n  // <https://github.com/micromark/micromark/blob/929275e/packages/micromark-util-sanitize-uri/dev/index.js#L34>\n  // But without the `encode` part.\n  const colon = value.indexOf(':')\n  const questionMark = value.indexOf('?')\n  const numberSign = value.indexOf('#')\n  const slash = value.indexOf('/')\n\n  if (\n    // If there is no protocol, it’s relative.\n    colon < 0 ||\n    // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign) ||\n    // It is a protocol, it should be allowed.\n    safeProtocol.test(value.slice(0, colon))\n  ) {\n    return value\n  }\n\n  return ''\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `blockquote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Blockquote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'blockquote',\n    properties: {},\n    children: state.wrap(state.all(node), true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `break` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Break} node\n *   mdast node.\n * @returns {Array<Element | Text>}\n *   hast element content.\n */\nexport function hardBreak(state, node) {\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'br', properties: {}, children: []}\n  state.patch(node, result)\n  return [state.applyData(node, result), {type: 'text', value: '\\n'}]\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `code` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Code} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function code(state, node) {\n  const value = node.value ? node.value + '\\n' : ''\n  /** @type {Properties} */\n  const properties = {}\n\n  if (node.lang) {\n    properties.className = ['language-' + node.lang]\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result = {\n    type: 'element',\n    tagName: 'code',\n    properties,\n    children: [{type: 'text', value}]\n  }\n\n  if (node.meta) {\n    result.data = {meta: node.meta}\n  }\n\n  state.patch(node, result)\n  result = state.applyData(node, result)\n\n  // Create `<pre>`.\n  result = {type: 'element', tagName: 'pre', properties: {}, children: [result]}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Delete} Delete\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `delete` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Delete} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strikethrough(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'del',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `emphasis` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Emphasis} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function emphasis(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'em',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `footnoteReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {FootnoteReference} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function footnoteReference(state, node) {\n  const clobberPrefix =\n    typeof state.options.clobberPrefix === 'string'\n      ? state.options.clobberPrefix\n      : 'user-content-'\n  const id = String(node.identifier).toUpperCase()\n  const safeId = normalizeUri(id.toLowerCase())\n  const index = state.footnoteOrder.indexOf(id)\n  /** @type {number} */\n  let counter\n\n  let reuseCounter = state.footnoteCounts.get(id)\n\n  if (reuseCounter === undefined) {\n    reuseCounter = 0\n    state.footnoteOrder.push(id)\n    counter = state.footnoteOrder.length\n  } else {\n    counter = index + 1\n  }\n\n  reuseCounter += 1\n  state.footnoteCounts.set(id, reuseCounter)\n\n  /** @type {Element} */\n  const link = {\n    type: 'element',\n    tagName: 'a',\n    properties: {\n      href: '#' + clobberPrefix + 'fn-' + safeId,\n      id:\n        clobberPrefix +\n        'fnref-' +\n        safeId +\n        (reuseCounter > 1 ? '-' + reuseCounter : ''),\n      dataFootnoteRef: true,\n      ariaDescribedBy: ['footnote-label']\n    },\n    children: [{type: 'text', value: String(counter)}]\n  }\n  state.patch(node, link)\n\n  /** @type {Element} */\n  const sup = {\n    type: 'element',\n    tagName: 'sup',\n    properties: {},\n    children: [link]\n  }\n  state.patch(node, sup)\n  return state.applyData(node, sup)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `heading` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Heading} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function heading(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'h' + node.depth,\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Html} Html\n * @typedef {import('../state.js').State} State\n * @typedef {import('../../index.js').Raw} Raw\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `html` node into hast (`raw` node in dangerous mode, otherwise\n * nothing).\n *\n * @param {State} state\n *   Info passed around.\n * @param {Html} node\n *   mdast node.\n * @returns {Element | Raw | undefined}\n *   hast node.\n */\nexport function html(state, node) {\n  if (state.options.allowDangerousHtml) {\n    /** @type {Raw} */\n    const result = {type: 'raw', value: node.value}\n    state.patch(node, result)\n    return state.applyData(node, result)\n  }\n\n  return undefined\n}\n", "/**\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Reference} Reference\n *\n * @typedef {import('./state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Return the content of a reference without definition as plain text.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Extract<Nodes, Reference>} node\n *   Reference node (image, link).\n * @returns {Array<ElementContent>}\n *   hast content.\n */\nexport function revert(state, node) {\n  const subtype = node.referenceType\n  let suffix = ']'\n\n  if (subtype === 'collapsed') {\n    suffix += '[]'\n  } else if (subtype === 'full') {\n    suffix += '[' + (node.label || node.identifier) + ']'\n  }\n\n  if (node.type === 'imageReference') {\n    return [{type: 'text', value: '![' + node.alt + suffix}]\n  }\n\n  const contents = state.all(node)\n  const head = contents[0]\n\n  if (head && head.type === 'text') {\n    head.value = '[' + head.value\n  } else {\n    contents.unshift({type: 'text', value: '['})\n  }\n\n  const tail = contents[contents.length - 1]\n\n  if (tail && tail.type === 'text') {\n    tail.value += suffix\n  } else {\n    contents.push({type: 'text', value: suffix})\n  }\n\n  return contents\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `imageReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ImageReference} node\n *   mdast node.\n * @returns {Array<ElementContent> | ElementContent}\n *   hast node.\n */\nexport function imageReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const def = state.definitionById.get(id)\n\n  if (!def) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(def.url || ''), alt: node.alt}\n\n  if (def.title !== null && def.title !== undefined) {\n    properties.title = def.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `image` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Image} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function image(state, node) {\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(node.url)}\n\n  if (node.alt !== null && node.alt !== undefined) {\n    properties.alt = node.alt\n  }\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `inlineCode` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {InlineCode} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {Text} */\n  const text = {type: 'text', value: node.value.replace(/\\r?\\n|\\r/g, ' ')}\n  state.patch(node, text)\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'code',\n    properties: {},\n    children: [text]\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `linkReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {LinkReference} node\n *   mdast node.\n * @returns {Array<ElementContent> | ElementContent}\n *   hast node.\n */\nexport function linkReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const def = state.definitionById.get(id)\n\n  if (!def) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(def.url || '')}\n\n  if (def.title !== null && def.title !== undefined) {\n    properties.title = def.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `link` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Link} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function link(state, node) {\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(node.url)}\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `listItem` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ListItem} node\n *   mdast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function listItem(state, node, parent) {\n  const results = state.all(node)\n  const loose = parent ? listLoose(parent) : listItemLoose(node)\n  /** @type {Properties} */\n  const properties = {}\n  /** @type {Array<ElementContent>} */\n  const children = []\n\n  if (typeof node.checked === 'boolean') {\n    const head = results[0]\n    /** @type {Element} */\n    let paragraph\n\n    if (head && head.type === 'element' && head.tagName === 'p') {\n      paragraph = head\n    } else {\n      paragraph = {type: 'element', tagName: 'p', properties: {}, children: []}\n      results.unshift(paragraph)\n    }\n\n    if (paragraph.children.length > 0) {\n      paragraph.children.unshift({type: 'text', value: ' '})\n    }\n\n    paragraph.children.unshift({\n      type: 'element',\n      tagName: 'input',\n      properties: {type: 'checkbox', checked: node.checked, disabled: true},\n      children: []\n    })\n\n    // According to github-markdown-css, this class hides bullet.\n    // See: <https://github.com/sindresorhus/github-markdown-css>.\n    properties.className = ['task-list-item']\n  }\n\n  let index = -1\n\n  while (++index < results.length) {\n    const child = results[index]\n\n    // Add eols before nodes, except if this is a loose, first paragraph.\n    if (\n      loose ||\n      index !== 0 ||\n      child.type !== 'element' ||\n      child.tagName !== 'p'\n    ) {\n      children.push({type: 'text', value: '\\n'})\n    }\n\n    if (child.type === 'element' && child.tagName === 'p' && !loose) {\n      children.push(...child.children)\n    } else {\n      children.push(child)\n    }\n  }\n\n  const tail = results[results.length - 1]\n\n  // Add a final eol.\n  if (tail && (loose || tail.type !== 'element' || tail.tagName !== 'p')) {\n    children.push({type: 'text', value: '\\n'})\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'li', properties, children}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * @param {Parents} node\n * @return {Boolean}\n */\nfunction listLoose(node) {\n  let loose = false\n  if (node.type === 'list') {\n    loose = node.spread || false\n    const children = node.children\n    let index = -1\n\n    while (!loose && ++index < children.length) {\n      loose = listItemLoose(children[index])\n    }\n  }\n\n  return loose\n}\n\n/**\n * @param {ListItem} node\n * @return {Boolean}\n */\nfunction listItemLoose(node) {\n  const spread = node.spread\n\n  return spread === null || spread === undefined\n    ? node.children.length > 1\n    : spread\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').List} List\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `list` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {List} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function list(state, node) {\n  /** @type {Properties} */\n  const properties = {}\n  const results = state.all(node)\n  let index = -1\n\n  if (typeof node.start === 'number' && node.start !== 1) {\n    properties.start = node.start\n  }\n\n  // Like GitHub, add a class for custom styling.\n  while (++index < results.length) {\n    const child = results[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'li' &&\n      child.properties &&\n      Array.isArray(child.properties.className) &&\n      child.properties.className.includes('task-list-item')\n    ) {\n      properties.className = ['contains-task-list']\n      break\n    }\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: node.ordered ? 'ol' : 'ul',\n    properties,\n    children: state.wrap(results, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `paragraph` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Paragraph} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function paragraph(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'p',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Parents} HastParents\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `root` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastRoot} node\n *   mdast node.\n * @returns {HastParents}\n *   hast node.\n */\nexport function root(state, node) {\n  /** @type {HastRoot} */\n  const result = {type: 'root', children: state.wrap(state.all(node))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `strong` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Strong} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strong(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'strong',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Table} Table\n * @typedef {import('../state.js').State} State\n */\n\nimport {pointEnd, pointStart} from 'unist-util-position'\n\n/**\n * Turn an mdast `table` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Table} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function table(state, node) {\n  const rows = state.all(node)\n  const firstRow = rows.shift()\n  /** @type {Array<Element>} */\n  const tableContent = []\n\n  if (firstRow) {\n    /** @type {Element} */\n    const head = {\n      type: 'element',\n      tagName: 'thead',\n      properties: {},\n      children: state.wrap([firstRow], true)\n    }\n    state.patch(node.children[0], head)\n    tableContent.push(head)\n  }\n\n  if (rows.length > 0) {\n    /** @type {Element} */\n    const body = {\n      type: 'element',\n      tagName: 'tbody',\n      properties: {},\n      children: state.wrap(rows, true)\n    }\n\n    const start = pointStart(node.children[1])\n    const end = pointEnd(node.children[node.children.length - 1])\n    if (start && end) body.position = {start, end}\n    tableContent.push(body)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'table',\n    properties: {},\n    children: state.wrap(tableContent, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function tableRow(state, node, parent) {\n  const siblings = parent ? parent.children : undefined\n  // Generate a body row when without parent.\n  const rowIndex = siblings ? siblings.indexOf(node) : 1\n  const tagName = rowIndex === 0 ? 'th' : 'td'\n  // To do: option to use `style`?\n  const align = parent && parent.type === 'table' ? parent.align : undefined\n  const length = align ? align.length : node.children.length\n  let cellIndex = -1\n  /** @type {Array<ElementContent>} */\n  const cells = []\n\n  while (++cellIndex < length) {\n    // Note: can also be undefined.\n    const cell = node.children[cellIndex]\n    /** @type {Properties} */\n    const properties = {}\n    const alignValue = align ? align[cellIndex] : undefined\n\n    if (alignValue) {\n      properties.align = alignValue\n    }\n\n    /** @type {Element} */\n    let result = {type: 'element', tagName, properties, children: []}\n\n    if (cell) {\n      result.children = state.all(cell)\n      state.patch(cell, result)\n      result = state.applyData(cell, result)\n    }\n\n    cells.push(result)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'tr',\n    properties: {},\n    children: state.wrap(cells, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `tableCell` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableCell} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function tableCell(state, node) {\n  // Note: this function is normally not called: see `table-row` for how rows\n  // and their cells are compiled.\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'td', // Assume body cell.\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "const tab = 9 /* `\\t` */\nconst space = 32 /* ` ` */\n\n/**\n * Remove initial and final spaces and tabs at the line breaks in `value`.\n * Does not trim initial and final spaces and tabs of the value itself.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Trimmed value.\n */\nexport function trimLines(value) {\n  const source = String(value)\n  const search = /\\r?\\n|\\r/g\n  let match = search.exec(source)\n  let last = 0\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (match) {\n    lines.push(\n      trimLine(source.slice(last, match.index), last > 0, true),\n      match[0]\n    )\n\n    last = match.index + match[0].length\n    match = search.exec(source)\n  }\n\n  lines.push(trimLine(source.slice(last), last > 0, false))\n\n  return lines.join('')\n}\n\n/**\n * @param {string} value\n *   Line to trim.\n * @param {boolean} start\n *   Whether to trim the start of the line.\n * @param {boolean} end\n *   Whether to trim the end of the line.\n * @returns {string}\n *   Trimmed line.\n */\nfunction trimLine(value, start, end) {\n  let startIndex = 0\n  let endIndex = value.length\n\n  if (start) {\n    let code = value.codePointAt(startIndex)\n\n    while (code === tab || code === space) {\n      startIndex++\n      code = value.codePointAt(startIndex)\n    }\n  }\n\n  if (end) {\n    let code = value.codePointAt(endIndex - 1)\n\n    while (code === tab || code === space) {\n      endIndex--\n      code = value.codePointAt(endIndex - 1)\n    }\n  }\n\n  return endIndex > startIndex ? value.slice(startIndex, endIndex) : ''\n}\n", "/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('mdast').Text} MdastText\n * @typedef {import('../state.js').State} State\n */\n\nimport {trimLines} from 'trim-lines'\n\n/**\n * Turn an mdast `text` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastText} node\n *   mdast node.\n * @returns {HastElement | HastText}\n *   hast node.\n */\nexport function text(state, node) {\n  /** @type {HastText} */\n  const result = {type: 'text', value: trimLines(String(node.value))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `thematicBreak` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ThematicBreak} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function thematicBreak(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'hr',\n    properties: {},\n    children: []\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n", "import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {strikethrough} from './delete.js'\nimport {emphasis} from './emphasis.js'\nimport {footnoteReference} from './footnote-reference.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {imageReference} from './image-reference.js'\nimport {image} from './image.js'\nimport {inlineCode} from './inline-code.js'\nimport {linkReference} from './link-reference.js'\nimport {link} from './link.js'\nimport {listItem} from './list-item.js'\nimport {list} from './list.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {table} from './table.js'\nimport {tableRow} from './table-row.js'\nimport {tableCell} from './table-cell.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default handlers for nodes.\n *\n * @satisfies {import('../state.js').Handlers}\n */\nexport const handlers = {\n  blockquote,\n  break: hardBreak,\n  code,\n  delete: strikethrough,\n  emphasis,\n  footnoteReference,\n  heading,\n  html,\n  imageReference,\n  image,\n  inlineCode,\n  linkReference,\n  link,\n  listItem,\n  list,\n  paragraph,\n  // @ts-expect-error: root is different, but hard to type.\n  root,\n  strong,\n  table,\n  tableCell,\n  tableRow,\n  text,\n  thematicBreak,\n  toml: ignore,\n  yaml: ignore,\n  definition: ignore,\n  footnoteDefinition: ignore\n}\n\n// Return nothing for nodes that are ignored.\nfunction ignore() {\n  return undefined\n}\n", "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('./state.js').State} State\n */\n\n/**\n * @callback FootnoteBackContentTemplate\n *   Generate content for the backreference dynamically.\n *\n *   For the following markdown:\n *\n *   ```markdown\n *   Alpha[^micromark], bravo[^micromark], and charlie[^remark].\n *\n *   [^remark]: things about remark\n *   [^micromark]: things about micromark\n *   ```\n *\n *   This function will be called with:\n *\n *   *  `0` and `0` for the backreference from `things about micromark` to\n *      `alpha`, as it is the first used definition, and the first call to it\n *   *  `0` and `1` for the backreference from `things about micromark` to\n *      `bravo`, as it is the first used definition, and the second call to it\n *   *  `1` and `0` for the backreference from `things about remark` to\n *      `charlie`, as it is the second used definition\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {Array<ElementContent> | ElementContent | string}\n *   Content for the backreference when linking back from definitions to their\n *   reference.\n *\n * @callback FootnoteBackLabelTemplate\n *   Generate a back label dynamically.\n *\n *   For the following markdown:\n *\n *   ```markdown\n *   Alpha[^micromark], bravo[^micromark], and charlie[^remark].\n *\n *   [^remark]: things about remark\n *   [^micromark]: things about micromark\n *   ```\n *\n *   This function will be called with:\n *\n *   *  `0` and `0` for the backreference from `things about micromark` to\n *      `alpha`, as it is the first used definition, and the first call to it\n *   *  `0` and `1` for the backreference from `things about micromark` to\n *      `bravo`, as it is the first used definition, and the second call to it\n *   *  `1` and `0` for the backreference from `things about remark` to\n *      `charlie`, as it is the second used definition\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Back label to use when linking back from definitions to their reference.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Generate the default content that GitHub uses on backreferences.\n *\n * @param {number} _\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {Array<ElementContent>}\n *   Content.\n */\nexport function defaultFootnoteBackContent(_, rereferenceIndex) {\n  /** @type {Array<ElementContent>} */\n  const result = [{type: 'text', value: '↩'}]\n\n  if (rereferenceIndex > 1) {\n    result.push({\n      type: 'element',\n      tagName: 'sup',\n      properties: {},\n      children: [{type: 'text', value: String(rereferenceIndex)}]\n    })\n  }\n\n  return result\n}\n\n/**\n * Generate the default label that GitHub uses on backreferences.\n *\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Label.\n */\nexport function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n  return (\n    'Back to reference ' +\n    (referenceIndex + 1) +\n    (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n  )\n}\n\n/**\n * Generate a hast footer for called footnote definitions.\n *\n * @param {State} state\n *   Info passed around.\n * @returns {Element | undefined}\n *   `section` element or `undefined`.\n */\n// eslint-disable-next-line complexity\nexport function footer(state) {\n  const clobberPrefix =\n    typeof state.options.clobberPrefix === 'string'\n      ? state.options.clobberPrefix\n      : 'user-content-'\n  const footnoteBackContent =\n    state.options.footnoteBackContent || defaultFootnoteBackContent\n  const footnoteBackLabel =\n    state.options.footnoteBackLabel || defaultFootnoteBackLabel\n  const footnoteLabel = state.options.footnoteLabel || 'Footnotes'\n  const footnoteLabelTagName = state.options.footnoteLabelTagName || 'h2'\n  const footnoteLabelProperties = state.options.footnoteLabelProperties || {\n    className: ['sr-only']\n  }\n  /** @type {Array<ElementContent>} */\n  const listItems = []\n  let referenceIndex = -1\n\n  while (++referenceIndex < state.footnoteOrder.length) {\n    const def = state.footnoteById.get(state.footnoteOrder[referenceIndex])\n\n    if (!def) {\n      continue\n    }\n\n    const content = state.all(def)\n    const id = String(def.identifier).toUpperCase()\n    const safeId = normalizeUri(id.toLowerCase())\n    let rereferenceIndex = 0\n    /** @type {Array<ElementContent>} */\n    const backReferences = []\n    const counts = state.footnoteCounts.get(id)\n\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (counts !== undefined && ++rereferenceIndex <= counts) {\n      if (backReferences.length > 0) {\n        backReferences.push({type: 'text', value: ' '})\n      }\n\n      let children =\n        typeof footnoteBackContent === 'string'\n          ? footnoteBackContent\n          : footnoteBackContent(referenceIndex, rereferenceIndex)\n\n      if (typeof children === 'string') {\n        children = {type: 'text', value: children}\n      }\n\n      backReferences.push({\n        type: 'element',\n        tagName: 'a',\n        properties: {\n          href:\n            '#' +\n            clobberPrefix +\n            'fnref-' +\n            safeId +\n            (rereferenceIndex > 1 ? '-' + rereferenceIndex : ''),\n          dataFootnoteBackref: '',\n          ariaLabel:\n            typeof footnoteBackLabel === 'string'\n              ? footnoteBackLabel\n              : footnoteBackLabel(referenceIndex, rereferenceIndex),\n          className: ['data-footnote-backref']\n        },\n        children: Array.isArray(children) ? children : [children]\n      })\n    }\n\n    const tail = content[content.length - 1]\n\n    if (tail && tail.type === 'element' && tail.tagName === 'p') {\n      const tailTail = tail.children[tail.children.length - 1]\n      if (tailTail && tailTail.type === 'text') {\n        tailTail.value += ' '\n      } else {\n        tail.children.push({type: 'text', value: ' '})\n      }\n\n      tail.children.push(...backReferences)\n    } else {\n      content.push(...backReferences)\n    }\n\n    /** @type {Element} */\n    const listItem = {\n      type: 'element',\n      tagName: 'li',\n      properties: {id: clobberPrefix + 'fn-' + safeId},\n      children: state.wrap(content, true)\n    }\n\n    state.patch(def, listItem)\n\n    listItems.push(listItem)\n  }\n\n  if (listItems.length === 0) {\n    return\n  }\n\n  return {\n    type: 'element',\n    tagName: 'section',\n    properties: {dataFootnotes: true, className: ['footnotes']},\n    children: [\n      {\n        type: 'element',\n        tagName: footnoteLabelTagName,\n        properties: {\n          ...structuredClone(footnoteLabelProperties),\n          id: 'footnote-label'\n        },\n        children: [{type: 'text', value: footnoteLabel}]\n      },\n      {type: 'text', value: '\\n'},\n      {\n        type: 'element',\n        tagName: 'ol',\n        properties: {},\n        children: state.wrap(listItems, true)\n      },\n      {type: 'text', value: '\\n'}\n    ]\n  }\n}\n", "/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').RootContent} HastRootContent\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('mdast').Parents} MdastParents\n *\n * @typedef {import('vfile').VFile} VFile\n *\n * @typedef {import('./footer.js').FootnoteBackContentTemplate} FootnoteBackContentTemplate\n * @typedef {import('./footer.js').FootnoteBackLabelTemplate} FootnoteBackLabelTemplate\n */\n\n/**\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<HastElementContent> | HastElementContent | undefined}\n *   hast node.\n *\n * @typedef {Partial<Record<MdastNodes['type'], Handler>>} Handlers\n *   Handle nodes.\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree (default:\n *   `false`).\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` property on footnotes to prevent them from\n *   *clobbering* (default: `'user-content-'`).\n *\n *   Pass `''` for trusted markdown and when you are careful with\n *   polyfilling.\n *   You could pass a different prefix.\n *\n *   DOM clobbering is this:\n *\n *   ```html\n *   <p id=\"x\"></p>\n *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>\n *   ```\n *\n *   The above example shows that elements are made available by browsers, by\n *   their ID, on the `window` object.\n *   This is a security risk because you might be expecting some other variable\n *   at that place.\n *   It can also break polyfills.\n *   Using a prefix solves these problems.\n * @property {VFile | null | undefined} [file]\n *   Corresponding virtual file representing the input document (optional).\n * @property {FootnoteBackContentTemplate | string | null | undefined} [footnoteBackContent]\n *   Content of the backreference back to references (default: `defaultFootnoteBackContent`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackContent(_, rereferenceIndex) {\n *     const result = [{type: 'text', value: '↩'}]\n *\n *     if (rereferenceIndex > 1) {\n *       result.push({\n *         type: 'element',\n *         tagName: 'sup',\n *         properties: {},\n *         children: [{type: 'text', value: String(rereferenceIndex)}]\n *       })\n *     }\n *\n *     return result\n *   }\n *   ```\n *\n *   This content is used in the `a` element of each backreference (the `↩`\n *   links).\n * @property {FootnoteBackLabelTemplate | string | null | undefined} [footnoteBackLabel]\n *   Label to describe the backreference back to references (default:\n *   `defaultFootnoteBackLabel`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n *    return (\n *      'Back to reference ' +\n *      (referenceIndex + 1) +\n *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n *    )\n *   }\n *   ```\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is used in the `ariaLabel` property on each backreference\n *   (the `↩` links).\n *   It affects users of assistive technology.\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Textual label to use for the footnotes section (default: `'Footnotes'`).\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (default: `{className:\n *   ['sr-only']}`).\n *\n *   Change it to show the label and add other properties.\n *\n *   This label is typically hidden visually (assuming an `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass an empty string.\n *   You can also add different properties.\n *\n *   > 👉 **Note**: `id: 'footnote-label'` is always added, because footnote\n *   > calls use it with `aria-describedby` to provide an accessible label.\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   HTML tag name to use for the footnote label element (default: `'h2'`).\n *\n *   Change it to match your document structure.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes (optional).\n * @property {Array<MdastNodes['type']> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed)\n *   (optional).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes (optional).\n *\n * @typedef State\n *   Info passed around.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => HastElement | Type} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {Map<string, MdastDefinition>} definitionById\n *   Definitions by their identifier.\n * @property {Map<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Map<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {(node: MdastNodes, parent: MdastParents | undefined) => Array<HastElementContent> | HastElementContent | undefined} one\n *   Transform an mdast node to hast.\n * @property {Options} options\n *   Configuration.\n * @property {(from: MdastNodes, node: HastNodes) => undefined} patch\n *   Copy a node’s positional info.\n * @property {<Type extends HastRootContent>(nodes: Array<Type>, loose?: boolean | undefined) => Array<HastText | Type>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {visit} from 'unist-util-visit'\nimport {position} from 'unist-util-position'\nimport {handlers as defaultHandlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {State}\n *   `state` function.\n */\nexport function createState(tree, options) {\n  const settings = options || emptyOptions\n  /** @type {Map<string, MdastDefinition>} */\n  const definitionById = new Map()\n  /** @type {Map<string, MdastFootnoteDefinition>} */\n  const footnoteById = new Map()\n  /** @type {Map<string, number>} */\n  const footnoteCounts = new Map()\n  /** @type {Handlers} */\n  // @ts-expect-error: the root handler returns a root.\n  // Hard to type.\n  const handlers = {...defaultHandlers, ...settings.handlers}\n\n  /** @type {State} */\n  const state = {\n    all,\n    applyData,\n    definitionById,\n    footnoteById,\n    footnoteCounts,\n    footnoteOrder: [],\n    handlers,\n    one,\n    options: settings,\n    patch,\n    wrap\n  }\n\n  visit(tree, function (node) {\n    if (node.type === 'definition' || node.type === 'footnoteDefinition') {\n      const map = node.type === 'definition' ? definitionById : footnoteById\n      const id = String(node.identifier).toUpperCase()\n\n      // Mimick CM behavior of link definitions.\n      // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/9032189/lib/index.js#L20-L21>.\n      if (!map.has(id)) {\n        // @ts-expect-error: node type matches map.\n        map.set(id, node)\n      }\n    }\n  })\n\n  return state\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {Array<HastElementContent> | HastElementContent | undefined}\n   *   Resulting hast node.\n   */\n  function one(node, parent) {\n    const type = node.type\n    const handle = state.handlers[type]\n\n    if (own.call(state.handlers, type) && handle) {\n      return handle(state, node, parent)\n    }\n\n    if (state.options.passThrough && state.options.passThrough.includes(type)) {\n      if ('children' in node) {\n        const {children, ...shallow} = node\n        const result = structuredClone(shallow)\n        // @ts-expect-error: TS doesn’t understand…\n        result.children = state.all(node)\n        // @ts-expect-error: TS doesn’t understand…\n        return result\n      }\n\n      // @ts-expect-error: it’s custom.\n      return structuredClone(node)\n    }\n\n    const unknown = state.options.unknownHandler || defaultUnknownHandler\n\n    return unknown(state, node, parent)\n  }\n\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n  function all(parent) {\n    /** @type {Array<HastElementContent>} */\n    const values = []\n\n    if ('children' in parent) {\n      const nodes = parent.children\n      let index = -1\n      while (++index < nodes.length) {\n        const result = state.one(nodes[index], parent)\n\n        // To do: see if we van clean this? Can we merge texts?\n        if (result) {\n          if (index && nodes[index - 1].type === 'break') {\n            if (!Array.isArray(result) && result.type === 'text') {\n              result.value = trimMarkdownSpaceStart(result.value)\n            }\n\n            if (!Array.isArray(result) && result.type === 'element') {\n              const head = result.children[0]\n\n              if (head && head.type === 'text') {\n                head.value = trimMarkdownSpaceStart(head.value)\n              }\n            }\n          }\n\n          if (Array.isArray(result)) {\n            values.push(...result)\n          } else {\n            values.push(result)\n          }\n        }\n      }\n    }\n\n    return values\n  }\n}\n\n/**\n * Copy a node’s positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from)\n}\n\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {HastElement | Type}\n *   Nothing.\n */\nfunction applyData(from, to) {\n  /** @type {HastElement | Type} */\n  let result = to\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName\n    const hChildren = from.data.hChildren\n    const hProperties = from.data.hProperties\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent of `hName` is to create an element, but likely also to keep\n      // the content around (otherwise: pass `hChildren`).\n      else {\n        /** @type {Array<HastElementContent>} */\n        // @ts-expect-error: assume no doctypes in `root`.\n        const children = 'children' in result ? result.children : [result]\n        result = {type: 'element', tagName: hName, properties: {}, children}\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      Object.assign(result.properties, structuredClone(hProperties))\n    }\n\n    if (\n      'children' in result &&\n      result.children &&\n      hChildren !== null &&\n      hChildren !== undefined\n    ) {\n      result.children = hChildren\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastElement | HastText}\n *   Resulting hast node.\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {}\n  /** @type {HastElement | HastText} */\n  const result =\n    'value' in node &&\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\n      ? {type: 'text', value: node.value}\n      : {\n          type: 'element',\n          tagName: 'div',\n          properties: {},\n          children: state.all(node)\n        }\n\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastRootContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | undefined} [loose=false]\n *   Whether to add line endings at start and end (default: `false`).\n * @returns {Array<HastText | Type>}\n *   Wrapped nodes.\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<HastText | Type>} */\n  const result = []\n  let index = -1\n\n  if (loose) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({type: 'text', value: '\\n'})\n    result.push(nodes[index])\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  return result\n}\n\n/**\n * Trim spaces and tabs at the start of `value`.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Result.\n */\nfunction trimMarkdownSpaceStart(value) {\n  let index = 0\n  let code = value.charCodeAt(index)\n\n  while (code === 9 || code === 32) {\n    index++\n    code = value.charCodeAt(index)\n  }\n\n  return value.slice(index)\n}\n", "/**\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('./state.js').Options} Options\n */\n\nimport {ok as assert} from 'devlop'\nimport {footer} from './footer.js'\nimport {createState} from './state.js'\n\n/**\n * Transform mdast to hast.\n *\n * ##### Notes\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most utilities ignore `raw` nodes but two notable ones don’t:\n *\n * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will\n *     output the raw HTML.\n *     This is typically discouraged as noted by the option name but is useful\n *     if you completely trust authors\n * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them\n *     into standard hast nodes (`element`, `text`, etc).\n *     This is a heavy task as it needs a full HTML parser, but it is the only\n *     way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark, which we follow by default.\n * They are supported by GitHub, so footnotes can be enabled in markdown with\n * `mdast-util-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes, which is hidden for sighted users but shown to\n * assistive technology.\n * When your page is not in English, you must define translated values.\n *\n * Back references use ARIA attributes, but the section label itself uses a\n * heading that is hidden with an `sr-only` class.\n * To show it to sighted users, define different attributes in\n * `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem, as it links footnote calls to footnote\n * definitions on the page through `id` attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * Example: headings (DOM clobbering) in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isn’t in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * *   when the node has a `value` (and doesn’t have `data.hName`,\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\n *     node\n * *   otherwise, create a `<div>` element (which could be changed with\n *     `data.hName`), with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @param {MdastNodes} tree\n *   mdast tree.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {HastNodes}\n *   hast tree.\n */\nexport function toHast(tree, options) {\n  const state = createState(tree, options)\n  const node = state.one(tree, undefined)\n  const foot = footer(state)\n  /** @type {HastNodes} */\n  const result = Array.isArray(node)\n    ? {type: 'root', children: node}\n    : node || {type: 'root', children: []}\n\n  if (foot) {\n    // If there’s a footer, there were definitions, meaning block\n    // content.\n    // So `result` is a parent node.\n    assert('children' in result)\n    result.children.push({type: 'text', value: '\\n'}, foot)\n  }\n\n  return result\n}\n", "// Include `data` fields in mdast and `raw` nodes in hast.\n/// <reference types=\"mdast-util-to-hast\" />\n\n/**\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('mdast-util-to-hast').Options} ToHastOptions\n * @typedef {import('unified').Processor} Processor\n * @typedef {import('vfile').VFile} VFile\n */\n\n/**\n * @typedef {Omit<ToHastOptions, 'file'>} Options\n *\n * @callback TransformBridge\n *   Bridge-mode.\n *\n *   Runs the destination with the new hast tree.\n *   Discards result.\n * @param {MdastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {Promise<undefined>}\n *   Nothing.\n *\n * @callback TransformMutate\n *  Mutate-mode.\n *\n *  Further transformers run on the hast tree.\n * @param {MdastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {HastRoot}\n *   Tree (hast).\n */\n\nimport {toHast} from 'mdast-util-to-hast'\n\n/**\n * Turn markdown into HTML.\n *\n * ##### Notes\n *\n * ###### Signature\n *\n * *   if a processor is given, runs the (rehype) plugins used on it with a\n *     hast tree, then discards the result (*bridge mode*)\n * *   otherwise, returns a hast tree, the plugins used after `remarkRehype`\n *     are rehype plugins (*mutate mode*)\n *\n * > 👉 **Note**: It’s highly unlikely that you want to pass a `processor`.\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most plugins ignore `raw` nodes but two notable ones don’t:\n *\n * *   `rehype-stringify` also has an option `allowDangerousHtml` which will\n *     output the raw HTML.\n *     This is typically discouraged as noted by the option name but is useful if\n *     you completely trust authors\n * *   `rehype-raw` can handle the raw embedded HTML strings by parsing them\n *     into standard hast nodes (`element`, `text`, etc).\n *     This is a heavy task as it needs a full HTML parser, but it is the only way\n *     to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark, which we follow by default.\n * They are supported by GitHub, so footnotes can be enabled in markdown with\n * `remark-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes, which is hidden for sighted users but shown to\n * assistive technology.\n * When your page is not in English, you must define translated values.\n *\n * Back references use ARIA attributes, but the section label itself uses a\n * heading that is hidden with an `sr-only` class.\n * To show it to sighted users, define different attributes in\n * `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem, as it links footnote calls to footnote\n * definitions on the page through `id` attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * *Example: headings (DOM clobbering)* in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isn’t in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * *   when the node has a `value` (and doesn’t have `data.hName`,\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\n *     node\n * *   otherwise, create a `<div>` element (which could be changed with\n *     `data.hName`), with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @overload\n * @param {Processor} processor\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformBridge}\n *\n * @overload\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformMutate}\n *\n * @param {Readonly<Options> | Processor | null | undefined} [destination]\n *   Processor or configuration (optional).\n * @param {Readonly<Options> | null | undefined} [options]\n *   When a processor was given, configuration (optional).\n * @returns {TransformBridge | TransformMutate}\n *   Transform.\n */\nexport default function remarkRehype(destination, options) {\n  if (destination && 'run' in destination) {\n    /**\n     * @type {TransformBridge}\n     */\n    return async function (tree, file) {\n      // Cast because root in -> root out.\n      const hastTree = /** @type {HastRoot} */ (\n        toHast(tree, {file, ...options})\n      )\n      await destination.run(hastTree, file)\n    }\n  }\n\n  /**\n   * @type {TransformMutate}\n   */\n  return function (tree, file) {\n    // Cast because root in -> root out.\n    return /** @type {HastRoot} */ (\n      toHast(tree, {file, ...(options || destination)})\n    )\n  }\n}\n"],
  "mappings": "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",
  "names": ["position", "start", "whitespace", "re", "StyleToObject", "name", "re", "esm_default", "StyleToObject", "point", "start", "jsx", "jsxs", "_", "point", "name", "stringify", "esm_default", "value", "link", "html", "text", "paragraph", "root", "start", "result", "start", "code", "text", "html", "root", "text", "listItem", "own", "emptyOptions", "handlers", "one", "code"]
}
