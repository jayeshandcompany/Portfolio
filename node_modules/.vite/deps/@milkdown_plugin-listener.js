import {
  $,
  H,
  M2 as M,
  N,
  Plugin,
  PluginKey,
  ne,
  te
} from "./chunk-WI6RX7S5.js";
import "./chunk-FB4UYON5.js";
import "./chunk-2RGGVGVQ.js";
import "./chunk-L35HEBJL.js";
import "./chunk-EUBN2JYL.js";
import "./chunk-YF7QOEZP.js";
import "./chunk-DUPPORCB.js";
import "./chunk-6UKNOZWC.js";
import {
  __commonJS,
  __toESM
} from "./chunk-WXXH56N5.js";

// node_modules/.pnpm/lodash.debounce@4.0.8/node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/.pnpm/lodash.debounce@4.0.8/node_modules/lodash.debounce/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = debounce;
  }
});

// node_modules/.pnpm/@milkdown+plugin-listener@7.3.6_@milkdown+core@7.3.6_@milkdown+ctx@7.3.6_@milkdown+prose@7.3._bravfuzaryg7ipzwmytbtcdiue/node_modules/@milkdown/plugin-listener/lib/index.es.js
var import_lodash = __toESM(require_lodash());
var l = class {
  constructor() {
    this.beforeMountedListeners = [], this.mountedListeners = [], this.updatedListeners = [], this.markdownUpdatedListeners = [], this.blurListeners = [], this.focusListeners = [], this.destroyListeners = [], this.beforeMount = (s) => (this.beforeMountedListeners.push(s), this), this.mounted = (s) => (this.mountedListeners.push(s), this), this.updated = (s) => (this.updatedListeners.push(s), this);
  }
  /// A getter to get all [subscribers](#interface-subscribers). You should not use this method directly.
  get listeners() {
    return {
      beforeMount: this.beforeMountedListeners,
      mounted: this.mountedListeners,
      updated: this.updatedListeners,
      markdownUpdated: this.markdownUpdatedListeners,
      blur: this.blurListeners,
      focus: this.focusListeners,
      destroy: this.destroyListeners
    };
  }
  /// Subscribe to the markdownUpdated event.
  /// This event will be triggered after the editor state is updated and **the document is changed**.
  /// The second parameter is the current markdown and the third parameter is the previous markdown.
  markdownUpdated(s) {
    return this.markdownUpdatedListeners.push(s), this;
  }
  /// Subscribe to the blur event.
  /// This event will be triggered when the editor is blurred.
  blur(s) {
    return this.blurListeners.push(s), this;
  }
  /// Subscribe to the focus event.
  /// This event will be triggered when the editor is focused.
  focus(s) {
    return this.focusListeners.push(s), this;
  }
  /// Subscribe to the destroy event.
  /// This event will be triggered before the editor is destroyed.
  destroy(s) {
    return this.destroyListeners.push(s), this;
  }
};
var h = H(new l(), "listener");
var M2 = new PluginKey("MILKDOWN_LISTENER");
var U = (t) => (t.inject(h, new l()), async () => {
  await t.wait(M);
  const s = t.get(h), { listeners: r } = s;
  r.beforeMount.forEach((e) => e(t)), await t.wait($);
  const u = t.get(te);
  let n = null, d = null;
  const p = new Plugin({
    key: M2,
    view: () => ({
      destroy: () => {
        r.destroy.forEach((e) => e(t));
      }
    }),
    props: {
      handleDOMEvents: {
        focus: () => (r.focus.forEach((e) => e(t)), false),
        blur: () => (r.blur.forEach((e) => e(t)), false)
      }
    },
    state: {
      init: (e, a) => {
        n = a.doc, d = u(a.doc);
      },
      apply: (e) => !e.docChanged || e.getMeta("addToHistory") === false ? void 0 : (0, import_lodash.default)(() => {
        const { doc: i } = e;
        if (r.updated.length > 0 && n && !n.eq(i) && r.updated.forEach((o) => {
          o(t, i, n);
        }), r.markdownUpdated.length > 0 && n && !n.eq(i)) {
          const o = u(i);
          r.markdownUpdated.forEach((f) => {
            f(t, o, d);
          }), d = o;
        }
        n = i;
      }, 200)()
    }
  });
  t.update(N, (e) => e.concat(p)), await t.wait(ne), r.mounted.forEach((e) => e(t));
});
U.meta = {
  package: "@milkdown/plugin-listener",
  displayName: "Listener"
};
export {
  l as ListenerManager,
  M2 as key,
  U as listener,
  h as listenerCtx
};
//# sourceMappingURL=@milkdown_plugin-listener.js.map
