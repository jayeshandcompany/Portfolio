import {
  Et,
  H,
  J,
  M,
  M2,
  N,
  R,
  X,
  Z,
  b,
  je,
  keymap,
  pe,
  ue,
  x
} from "./chunk-WI6RX7S5.js";

// node_modules/.pnpm/nanoid@5.0.7/node_modules/nanoid/index.browser.js
var random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
var customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  let step = -~(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let j = step;
      while (j--) {
        id += alphabet[bytes[j] & mask] || "";
        if (id.length === size)
          return id;
      }
    }
  };
};
var customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);

// node_modules/.pnpm/@milkdown+utils@7.3.6_@milkdown+core@7.3.6_@milkdown+ctx@7.3.6_@milkdown+prose@7.3.6_@milkdown+transformer@7.3.6/node_modules/@milkdown/utils/lib/index.es.js
var J2 = customAlphabet("abcedfghicklmn", 10);
function re(n, o) {
  const r = Et(n), t = (e) => async () => {
    t.key = r, await e.wait(J);
    const a = o(e);
    return e.get(je).create(r, a), t.run = (s) => e.get(je).call(n, s), () => {
      e.get(je).remove(r);
    };
  };
  return t;
}
function oe2(n) {
  const o = (r) => async () => {
    await r.wait(R);
    const t = n(r);
    return r.update(ue, (e) => [...e, t]), o.inputRule = t, () => {
      r.update(ue, (e) => e.filter((a) => a !== t));
    };
  };
  return o;
}
function Q(n, o) {
  const r = (t) => async () => {
    const e = o(t);
    return t.update(Z, (a) => [...a.filter((s) => s[0] !== n), [n, e]]), r.id = n, r.schema = e, () => {
      t.update(Z, (a) => a.filter(([s]) => s !== n));
    };
  };
  return r.type = (t) => {
    const e = t.get(b).marks[n];
    if (!e)
      throw x(n);
    return e;
  }, r;
}
function W(n, o) {
  const r = (t) => async () => {
    const e = o(t);
    return t.update(X, (a) => [...a.filter((s) => s[0] !== n), [n, e]]), r.id = n, r.schema = e, () => {
      t.update(X, (a) => a.filter(([s]) => s !== n));
    };
  };
  return r.type = (t) => {
    const e = t.get(b).nodes[n];
    if (!e)
      throw M(n);
    return e;
  }, r;
}
function ue2(n) {
  let o;
  const r = (t) => async () => (await t.wait(R), o = n(t), t.update(N, (e) => [...e, o]), () => {
    t.update(N, (e) => e.filter((a) => a !== o));
  });
  return r.plugin = () => o, r.key = () => o.spec.key, r;
}
function X2(n) {
  const o = (r) => async () => {
    await r.wait(R);
    const t = n(r), e = keymap(t);
    return r.update(N, (a) => [...a, e]), o.keymap = t, () => {
      r.update(N, (a) => a.filter((s) => s !== e));
    };
  };
  return o;
}
function h(n, o) {
  const r = H(n, o), t = (e) => (e.inject(r), () => () => {
    e.remove(r);
  });
  return t.key = r, t;
}
function fe2(n, o) {
  const r = h(o, n), t = W(n, (a) => a.get(r.key)(a)), e = [r, t];
  return e.id = t.id, e.node = t, e.type = (a) => t.type(a), e.schema = t.schema, e.ctx = r, e.key = r.key, e.extendSchema = (a) => (s) => () => {
    const i = s.get(r.key), c = a(i)(s);
    s.update(X, (m) => [...m.filter((S) => S[0] !== n), [n, c]]), e.schema = c;
  }, e;
}
function ye2(n, o) {
  const r = h(o, n), t = Q(n, (a) => a.get(r.key)(a)), e = [r, t];
  return e.id = t.id, e.mark = t, e.type = t.type, e.schema = t.schema, e.ctx = r, e.key = r.key, e.extendSchema = (a) => (s) => () => {
    const i = s.get(r.key), c = a(i)(s);
    s.update(Z, (m) => [...m.filter((S) => S[0] !== n), [n, c]]), e.schema = c;
  }, e;
}
function ge(n, o) {
  const r = Object.fromEntries(Object.entries(o).map(([s, { shortcuts: i }]) => [s, i])), t = h(r, `${n}Keymap`), e = X2((s) => {
    const i = s.get(t.key), u = Object.entries(o).flatMap(([c, { command: m }]) => [i[c]].flat().map((V) => [V, m(s)]));
    return Object.fromEntries(u);
  }), a = [t, e];
  return a.ctx = t, a.shortcuts = e, a.key = t.key, a.keymap = e.keymap, a;
}
var he = (n, o = () => ({})) => h(o, `${n}Attr`);
var we = (n, o = () => ({})) => h(o, `${n}Attr`);
function ke(n, o, r) {
  const t = h(r ?? {}, n), e = (s) => async () => {
    await s.wait(M2);
    const u = {
      plugin: o(s),
      options: s.get(t.key)
    };
    return s.update(pe, (c) => [...c, u]), () => {
      s.update(pe, (c) => c.filter((m) => m !== u));
    };
  }, a = [t, e];
  return a.id = n, a.plugin = e, a.options = t, a;
}

export {
  re,
  oe2 as oe,
  W,
  ue2 as ue,
  h,
  fe2 as fe,
  ye2 as ye,
  ge,
  he,
  we,
  ke
};
//# sourceMappingURL=chunk-A3CANUO4.js.map
